<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>如何在 Python 中实现宏展开?</title>
    <link href="/2024/09/01/impl_macros_in_python/"/>
    <url>/2024/09/01/impl_macros_in_python/</url>
    
    <content type="html"><![CDATA[<h1 id="如何在-Python-中实现宏展开"><a href="#如何在-Python-中实现宏展开" class="headerlink" title="如何在 Python 中实现宏展开?"></a>如何在 Python 中实现宏展开?</h1><p>Python 的语法以灵活性见长，有时候可能需要动态地对一个模块进行修改，也就是为人熟知的 <code>Monkey Patch</code></p><p>普通的修改对于一些静态生成的常量效果有限，例如下面这段代码，尽管可以修改 <code>generator</code>，但并不会影响调用这个函数生成的变量的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generator</span>(<span class="hljs-params">name</span>):</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;static &quot;</span> + name<br><br>python = generator(<span class="hljs-string">&quot;python&quot;</span>)<br>rust = generator(<span class="hljs-string">&quot;rust&quot;</span>)<br></code></pre></td></tr></table></figure><p>那么有没有一种方法能够解决这个问题而又不直接修改这个文件？这个过程有点类似于许多语言的宏展开机制，因此本篇文章也取名为 <code>如何在 Python 中实现宏展开?</code></p><h2 id="什么是宏-Macro"><a href="#什么是宏-Macro" class="headerlink" title="什么是宏 (Macro)"></a>什么是宏 (Macro)</h2><p>简单地解释，宏就是在编译前对源代码进行替换。</p><p>C 中的宏最容易理解，下面这段代码就是对 <code>VAL</code> 进行了替换，不难理解.</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> VAL 123</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>, VAL);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>&gt;&gt;&gt; <span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><h2 id="Python-与-模块"><a href="#Python-与-模块" class="headerlink" title="Python 与 模块"></a>Python 与 模块</h2><p>Python 的模块是这样引入的</p><p>import -&gt; finder/loader -&gt; [compile to py_code] -&gt; write to <code>__py_cache__</code></p><p>是否重新编译写入 <code>py_code</code> 到缓存拥有校验，校验的标准可能是文件的时间戳或是哈希值</p><p>如果校验结果相同，会尝试复用 <code>__py_cache__</code>，而 <code>sys.dont_write_bytecode</code> 会影响读写 <code>__py_cache__</code></p><h2 id="Python-与-编译"><a href="#Python-与-编译" class="headerlink" title="Python 与 编译"></a>Python 与 编译</h2><p>Python 的编译是使用 <code>builtins.compile</code> 进行的，我们只需对这个函数进行修改，捕获并修改 <code>source</code> 便可达到宏的效果</p><p>而 <code>builtins.compile</code> 的其他参数可以帮你确定模块，例如 <code>filename</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> builtins<br><br>sys.dont_write_bytecode = <span class="hljs-literal">True</span><br><br>origin_compile = builtins.<span class="hljs-built_in">compile</span><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">source, *args, **kwargs</span>):</span><br>    <span class="hljs-keyword">return</span> origin_compile(source.replace(...), *args, **kwargs)<br><br>builtins.<span class="hljs-built_in">compile</span> = wrapper<br><br><span class="hljs-keyword">import</span> ...<br></code></pre></td></tr></table></figure><h2 id="Saleyo"><a href="#Saleyo" class="headerlink" title="Saleyo"></a>Saleyo</h2><p>Saleyo 提供了一套工具，推荐尝试使用😊</p><p><a href="https://pypi.org/project/saleyo/">https://pypi.org/project/saleyo/</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># targetmodule</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate</span>(<span class="hljs-params">name</span>):</span><br>    <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; hell world&quot;</span><br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticMap</span>:</span><br>    FIELD = generate(<span class="hljs-string">&quot;hello&quot;</span>)<br><br><span class="hljs-comment"># mixin</span><br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Any</span>, <span class="hljs-type">Union</span><br><span class="hljs-keyword">from</span> saleyo.decorator.<span class="hljs-built_in">compile</span> <span class="hljs-keyword">import</span> CompileToken, CompileBoundary<br><br><br><span class="hljs-meta">@CompileToken(<span class="hljs-params"><span class="hljs-keyword">lambda</span> info: <span class="hljs-string">&quot;targetmodule.py&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">str</span>(<span class="hljs-params">info.filename</span>)</span>)</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mixin_a</span>(<span class="hljs-params">token: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">bytes</span>, <span class="hljs-type">Any</span>]</span>):</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(token, <span class="hljs-built_in">bytes</span>):<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">return</span> token.replace(<span class="hljs-string">b&quot;hell world&quot;</span>, <span class="hljs-string">b&quot;bye&quot;</span>)<br><br><br><span class="hljs-keyword">with</span> CompileBoundary(): <span class="hljs-comment"># Force to compile</span><br>    <span class="hljs-keyword">from</span> targetmodule <span class="hljs-keyword">import</span> StaticMap<br><br><span class="hljs-built_in">print</span>(StaticMap().FIELD)  <span class="hljs-comment"># hello bye</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>hello bye<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Macros</tag>
      
      <tag>Black Magic</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>异步编程中的阻塞、并发与并行</title>
    <link href="/2024/07/25/async_block_concurrent/"/>
    <url>/2024/07/25/async_block_concurrent/</url>
    
    <content type="html"><![CDATA[<h1 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h1><h2 id="引言-什么是-await"><a href="#引言-什么是-await" class="headerlink" title="引言: 什么是 await ?"></a>引言: 什么是 <code>await</code> ?</h2><p>在异步编程中，<code>await</code> 是一个很重要的语法，使用 <code>await</code> 来解析异步操作等待获取值是很常见的事情，因此，初学异步编程时，我们会理所当然地在所有地方使用 <code>await</code>。</p><p>但你真的确定你知道 <code>await</code> 为你做了什么吗？以及你是否有思考过，这样使用 <code>await</code> 最终和同步代码相比究竟有什么不同？</p><p>本篇文章就以这两个问题出发，对异步编程进行一些思考，希望对你学习异步编程能有帮助。</p><p>如有错误，请不吝赐教！</p><h2 id="await-与阻塞"><a href="#await-与阻塞" class="headerlink" title="await 与阻塞"></a>await 与阻塞</h2><p>毫无疑问 <code>await</code> 是阻塞的，你可以尝试运行以下的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::test]</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">await_block</span></span>() &#123;<br>    <span class="hljs-keyword">use</span> std::time::Duration;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(count: <span class="hljs-built_in">u64</span>) &#123;<br>        tokio::time::sleep(Duration::from_secs(count)).<span class="hljs-keyword">await</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>    &#125;<br><br>    foo(<span class="hljs-number">3</span>).<span class="hljs-keyword">await</span>;<br>    foo(<span class="hljs-number">2</span>).<span class="hljs-keyword">await</span>;<br>    foo(<span class="hljs-number">1</span>).<span class="hljs-keyword">await</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果是 <code>3 2 1</code></p><p>很显然，这一段代码与它的同步的差别不大。</p><p>对于一些 GUI程序 来说，阻塞是<strong>致命</strong>的，阻塞意味着停止渲染 UI，这将会导致程序界面的卡死，尽管实际上程序正在运行。</p><h1 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h1><h2 id="多线程语言的-join-spawn"><a href="#多线程语言的-join-spawn" class="headerlink" title="多线程语言的 join/spawn"></a>多线程语言的 join/spawn</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[tokio::test]</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">await_block</span></span>() &#123;<br>    <span class="hljs-keyword">use</span> std::time::Duration;<br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">foo</span></span>(count: <span class="hljs-built_in">u64</span>) &#123;<br>        tokio::time::sleep(Duration::from_secs(count)).<span class="hljs-keyword">await</span>;<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, count);<br>    &#125;<br><br>    tokio::join!(foo(<span class="hljs-number">3</span>), foo(<span class="hljs-number">2</span>), foo(<span class="hljs-number">1</span>)); <span class="hljs-comment">// tokio::spawn(foo(3)); ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果将是 <code>1 2 3</code> <del>意味着你可以拿它来写睡眠排序</del></p><blockquote><p>By running all async expressions on the current task, the expressions are able to run concurrently but not in parallel. This means all expressions are run on the same thread and if one branch blocks the thread, all other expressions will be unable to continue. If parallelism is required, spawn each async expression using tokio::spawn and pass the join handle to join!.</p><p><a href="https://docs.rs/tokio/latest/tokio/macro.join.html#runtime-characteristics">https://docs.rs/tokio/latest/tokio/macro.join.html#runtime-characteristics</a></p></blockquote><p><code>join</code> 具有并发性, <code>spawn</code> 还具有并行性，对于I/O密集型任务，有一段等待数据的时间，<code>join</code>/<code>spawn</code>性能差异不大，这也是异步在I/O密集型场景高效的原因。</p><p>CPU密集型任务请使用 <code>spawn</code>。</p><h2 id="在-Dart-中进行并发"><a href="#在-Dart-中进行并发" class="headerlink" title="在 Dart 中进行并发"></a>在 Dart 中进行并发</h2><p>著名的单线程语言是 JavaScript，很遗憾，笔者没有接触过这门以函数出名的语言。</p><p>不过除了 JavaScript 以外，因 Flutter 而出名的 Dart 也是一门优秀的单线程语言 (尽管 Isolate 令人印象深刻)。</p><p>下面这个例子会输出 <code>1 2 3</code></p><p>如果在所有调用 <code>foo</code> 的地方加上 <code>await</code>，那就会变成 <code>3 2 1</code></p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>    foo(<span class="hljs-built_in">int</span> sec) <span class="hljs-keyword">async</span> =&gt;<br>        Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: sec)).then((_) =&gt; <span class="hljs-built_in">print</span>(sec));<br><br>    foo(<span class="hljs-number">3</span>);<br>    foo(<span class="hljs-number">2</span>);<br>    foo(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-keyword">await</span> Future.delayed(<span class="hljs-keyword">const</span> <span class="hljs-built_in">Duration</span>(seconds: <span class="hljs-number">6</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你关注异步任务的返回值，你可以使用 <code>Future.wait</code>.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>    foo(<span class="hljs-built_in">int</span> sec) <span class="hljs-keyword">async</span> =&gt;<br>        Future.delayed(<span class="hljs-built_in">Duration</span>(seconds: sec)).then((_) =&gt; <span class="hljs-built_in">print</span>(sec));<br><br>    <span class="hljs-keyword">var</span> data = <span class="hljs-keyword">await</span> Future.wait(<span class="hljs-built_in">List</span>.generate(<span class="hljs-number">3</span>, (index) =&gt; Future(()<span class="hljs-keyword">async</span>=&gt; foo(index))));<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>下面这两篇文章写的非常清晰，推荐阅读</p><p><a href="https://bingowith.me/2021/05/09/translation-async-what-is-blocking/">https://bingowith.me/2021/05/09/translation-async-what-is-blocking/</a></p><p><a href="https://medium.com/flutter-community/futures-async-await-threading-in-flutter-baeeab1c1fe3">https://medium.com/flutter-community/futures-async-await-threading-in-flutter-baeeab1c1fe3</a></p>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Dart</tag>
      
      <tag>Programming</tag>
      
      <tag>Async</tag>
      
      <tag>Tokio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过方法链（链式调用）简单来在面向对象中使用函数式编程</title>
    <link href="/2024/05/08/oop_with_fp_via_method_chain/"/>
    <url>/2024/05/08/oop_with_fp_via_method_chain/</url>
    
    <content type="html"><![CDATA[<h1 id="方法链"><a href="#方法链" class="headerlink" title="方法链"></a>方法链</h1><p>不着急来看什么是方法链，思考一下，如果让你使用Python设计一个<code>Person</code>类，需要带有名字与年龄，你会如何去设计？</p><p>如果你写的漂亮点就是这样。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    age = <span class="hljs-number">17</span><br>    name = <span class="hljs-string">&quot;Yakumo&quot;</span><br></code></pre></td></tr></table></figure><p>人的年龄是逐年增长的，如果你想要修改你<code>Person</code>实例的年龄，一般会怎么做呢？如果你懒一点直接<code>person.age += 1</code>，勤快的就再写个<code>set_age</code>方法，调用<code>person.set_age(17)</code>，如果又要修改名字呢？是重复以上的 <code>person.name = ...</code>吗，那未免有些啰嗦。</p><p>此时试想一下如果你在<code>set_age</code>返回<code>self</code>会怎么样？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Self<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    age = <span class="hljs-number">17</span><br>    name = <span class="hljs-string">&quot;Yakumo&quot;</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; Self:</span>...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_age</span>(<span class="hljs-params">self, age: <span class="hljs-built_in">int</span></span>) -&gt; Self:</span><br>        self.age = age<br>        <span class="hljs-keyword">return</span> self<br></code></pre></td></tr></table></figure><p>通过返回<code>self</code>你就可以继续调用<code>set_name</code>调用<code>set_age</code>…还可以写出下面这样的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">person = Person().set_name(<span class="hljs-string">&quot;Reimu&quot;</span>).set_age(<span class="hljs-number">16</span>)<br></code></pre></td></tr></table></figure><p>像这样子调用一个方法之后返回自身实例继续调用自身方法就是方法链，这样的调用方法也就是链式调用！</p><h1 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h1><p>在方法链中返回一个新的实例而不是实例本身，这也就是不可变性，一旦值确定后就不对其更改。</p><p>大多数情况下你需要为你的类实现一下复制方法，请看代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> Self<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span>:</span><br>    age = <span class="hljs-number">17</span><br>    name = <span class="hljs-string">&quot;Yakumo&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; Self:</span><br>        <span class="hljs-keyword">return</span> Person.copy(self.age, name)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_age</span>(<span class="hljs-params">self, age: <span class="hljs-built_in">int</span></span>) -&gt; Self:</span><br>        <span class="hljs-keyword">return</span> Person.copy(age, self.name)<br><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">copy</span>(<span class="hljs-params">age: <span class="hljs-built_in">int</span>, name: <span class="hljs-built_in">str</span></span>) -&gt; &quot;Person&quot;:</span><br>        <span class="hljs-keyword">return</span> Person().set_age(age).set_name(name)<br></code></pre></td></tr></table></figure><p>间接来看，此时你的年龄与名称都是不可变的，并非修改实例而是创建新的实例，旧的实例通过某些机制回收释放，这也就是函数式的不可变性，对于Python这种写法可能没有多大的意义，但对于Dart来说可以为你的类打上<code>const</code>从而进行优化。</p>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code Aesthetic</tag>
      
      <tag>Python</tag>
      
      <tag>OOP</tag>
      
      <tag>FP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用rinf进行Rust与Flutter的集成与通信</title>
    <link href="/2024/02/10/how_to_use_rinf/"/>
    <url>/2024/02/10/how_to_use_rinf/</url>
    
    <content type="html"><![CDATA[<h1 id="使用rinf进行Rust与Flutter的集成与通信"><a href="#使用rinf进行Rust与Flutter的集成与通信" class="headerlink" title="使用rinf进行Rust与Flutter的集成与通信"></a>使用rinf进行Rust与Flutter的集成与通信</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Flutter和Rust之间的跨语言调用做着有一段时间了，从去年开始尝试手动写外部函数接口(FFI)，把动态库通过交叉编译手动放进文件夹到现在找一些便利的lib直接用起来，起初用的是FRB(flutter_rust_bridge)，但FRB这东西说实话有点繁重，直接生成一堆文件，我不太喜欢</p><p>这几天看到了rinf，觉得用的挺不错的，看了看关于rinf的文章不是很多，于是就稍微写写，如何使用还是建议参考<a href="https://rinf.cunarist.com/">官方文档</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装非常方便，当然了，你得先装好Flutter和Rust</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>找到你的 Flutter 项目根目录(下面简称根目录)运行下面这个命令添加依赖，或者你也可以手动安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">flutter pub add rinf<br></code></pre></td></tr></table></figure><p>安装之后可以使用<code>rinf --help</code>看看详细帮助</p><h3 id="生成模板文件"><a href="#生成模板文件" class="headerlink" title="生成模板文件"></a>生成模板文件</h3><p>使用这个命令来生成模板文件，模板代码也是文档的一部分，推荐进行参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">rinf template<br></code></pre></td></tr></table></figure><p>Rust相关的代码编写主要是在 <code>native/hub/src</code> 下</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="编写ProtoBuf"><a href="#编写ProtoBuf" class="headerlink" title="编写ProtoBuf"></a>编写ProtoBuf</h3><p>不会编写请先参考<a href="https://protobuf.dev/programming-guides/proto3/">文档</a></p><p>在messages文件夹下新建<code>foo.proto</code>(名称随意)，使用<code>proto3</code>进行编写即可</p><p>下面这段代码可以进行参考</p><p>其中<code>[RINF:DART-SIGNAL]</code>(从Dart向Rust传递的信息)和<code>[RINF:RUST-SIGNAL]</code>(从Rust向Dart发送的信息)并不是无意义的，rinf会根据这个来生成文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs proto">syntax &#x3D; &quot;proto3&quot;;<br>package foo;<br><br>&#x2F;&#x2F; [RINF:DART-SIGNAL]<br>message DataInput &#123;<br>    string username &#x3D; 1;<br>    string password &#x3D; 2;<br>&#125;;<br><br>&#x2F;&#x2F; [RINF:RUST-SIGNAL]<br>message DataOutput &#123;<br>    string data &#x3D; 1;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果你需要一个数组或者可选参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs proto">message Foo &#123;<br>    repeated string vec &#x3D; 1;<br>    optional string opt &#x3D; 2;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果需要引用其他proto文件中的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs proto">import &quot;path&#x2F;to&#x2F;foo.proto&quot;;<br><br>message Bar &#123;<br>    foo.Foo data &#x3D; 1;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>写完之后，根目录运行<code>rinf message</code>就可以看到文件生成了</p><h3 id="Rust侧的编写"><a href="#Rust侧的编写" class="headerlink" title="Rust侧的编写"></a>Rust侧的编写</h3><p>首先可以在<code>hub/src</code>下新建一个<code>foo.rs</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// foo.rs</span><br><br><span class="hljs-keyword">use</span> crate::messages::foo::&#123;DataInput, DataOutput&#125;;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">handle_data</span></span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> rev = DataInput::get_dart_signal_receiver();<br>    <span class="hljs-keyword">while</span> <span class="hljs-keyword">let</span> <span class="hljs-literal">Some</span>(dart_signal) = rev.recv().<span class="hljs-keyword">await</span> &#123;<br>        <span class="hljs-comment">// 处理接受来的信息</span><br>        <span class="hljs-keyword">let</span> output: DataOutput = foo(dart_signal.message);<br>        <span class="hljs-comment">// 发送</span><br>        output.send_signal_to_dart(<span class="hljs-literal">None</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后还需要在主函数里添加一行<code>spawn</code>，这样rust侧的编写就完成了</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span> &#123;</span><br><span class="hljs-function">    // ...</span><br><span class="hljs-function">    <span class="hljs-title">tokio</span>::<span class="hljs-title">spawn</span></span>(handle_data());<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Flutter侧的编写"><a href="#Flutter侧的编写" class="headerlink" title="Flutter侧的编写"></a>Flutter侧的编写</h3><p>Flutter侧的代码默认会生成在<code>lib/messages</code>中，只需要关心<code>generated.dart</code>里的内容即可</p><p>需要先在主函数添加初始化Rust，并且添加生命周期确保关闭</p><p>在生成模板时，会帮你自动添加初始化的代码</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">void</span> main() <span class="hljs-keyword">async</span> &#123;<br>  <span class="hljs-comment">//...</span><br>  <span class="hljs-keyword">await</span> initializeRust(assignRustSignal);<br>  <span class="hljs-comment">//...</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAppState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">MyApp</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">final</span> _appLifecycleListener = AppLifecycleListener(<br>    onExitRequested: () &#123;<br>      finalizeRust();<br>      <span class="hljs-keyword">return</span> AppExitResponse.exit;<br>    &#125;,<br>  );<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose() &#123;<br>    <span class="hljs-keyword">super</span>.dispose();<br>    _appLifecycleListener.dispose();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后就可以进行调用了！下面是一个简单的例子。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">FooPage</span>&gt; </span>&#123;<br>  <span class="hljs-keyword">void</span> update(DataOutput data) =&gt; ...<br><br>  <span class="hljs-keyword">late</span> StreamSubscription&lt;RustSignal&lt;DataOutput&gt;&gt; _streamDataOutput;<br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState()&#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    _streamDataOutput = DataOutput.rustSignalStream.listen((signal) =&gt; update(signal.message));<br>  &#125;<br><br><br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> dispose()&#123;<br>    <span class="hljs-keyword">super</span>.dispose();<br>    _streamDataOutput.cancel();<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> Button(onTap: () =&gt; DataInput(<br>        username: <span class="hljs-string">&quot;Foo&quot;</span>,<br>        password: <span class="hljs-string">&quot;Bar&quot;</span>,<br>      ).sendSignalToRust()<br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>更推荐使用 <code>StreamBuilder</code>，代码更加清晰。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FooPageState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">State</span>&lt;<span class="hljs-title">FooPage</span>&gt; </span>&#123;<br>  <span class="hljs-meta">@override</span><br>  <span class="hljs-keyword">void</span> initState()&#123;<br>    <span class="hljs-keyword">super</span>.initState();<br>    DataInput(<br>      username: <span class="hljs-string">&quot;Foo&quot;</span>,<br>      password: <span class="hljs-string">&quot;Bar&quot;</span>,<br>    ).sendSignalToRust()<br>  &#125;<br><br>  <span class="hljs-meta">@override</span><br>  Widget build(BuildContext context) &#123;<br>    <span class="hljs-keyword">return</span> StreamBuilder(<br>      stream: DataOutput.rustSignalStream, <br>      builder: (context, snapshot)&#123;<br>        <span class="hljs-keyword">var</span> signal = snapshot.data;<br>        <span class="hljs-keyword">if</span> (signal == <span class="hljs-keyword">null</span>)&#123;<br>          <span class="hljs-keyword">return</span> ...<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Button(onTap: () =&gt; DataInput(<br>            username: <span class="hljs-string">&quot;Foo&quot;</span>,<br>            password: <span class="hljs-string">&quot;Bar&quot;</span>,<br>          ).sendSignalToRust()<br>        );<br>      &#125;<br>    );    <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Flutter</tag>
      
      <tag>rinf</tag>
      
      <tag>FFI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>谈谈代码美学</title>
    <link href="/2023/09/17/about_code_aesthetic/"/>
    <url>/2023/09/17/about_code_aesthetic/</url>
    
    <content type="html"><![CDATA[<h1 id="谈谈代码美学"><a href="#谈谈代码美学" class="headerlink" title="谈谈代码美学"></a>谈谈代码美学</h1><p>本篇文章仅仅阐述个人观点，如果有想法欢迎提出讨论</p><h2 id="什么是代码美学"><a href="#什么是代码美学" class="headerlink" title="什么是代码美学"></a>什么是代码美学</h2><p>最近看了一系列代码美学相关的视频，什么是代码美学，乍一听感觉是用代码画一幅画，雕几个雕塑之类的，其实并不，代码美感来源于良好的编程习惯与一些技巧，本篇文章谈谈我的拙见</p><p>对于一段代码来说，这段代码可读性高，干净简洁，便于使用或维护，那么这段代码就是具有美感的，这种代码往往质量较高，下面有一段不太漂亮的代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">/// 获取最小值的下标</span><br><span class="hljs-comment">/// 传入一个 i32 的 Vec</span><br><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_index</span></span>(i_vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> i: <span class="hljs-built_in">usize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> j: <span class="hljs-built_in">usize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> k: <span class="hljs-built_in">i32</span> = <span class="hljs-built_in">i32</span>::MAX;<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> i_vec &#123;<br>        <span class="hljs-keyword">if</span> v &lt; k &#123;<br>            k = v;<br>            j = i;<br>        &#125;<br>        i += <span class="hljs-number">1</span>;<br>    &#125;<br>    j<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码并不复杂，但解读起来也略有难度，<code>i</code>是当前下标，<code>j</code>是当前最小值下标，<code>k</code>是当前最小值，遍历<code>i_vec</code>，如果当前值<code>v</code>比<code>k</code>小，则替换<code>k</code>并把当前下标保存至<code>j</code></p><p>仔细想想，首先阻碍我们理解这段代码的是什么？</p><p>没错，就是变量的命名方式！</p><h2 id="代码美学与命名方式"><a href="#代码美学与命名方式" class="headerlink" title="代码美学与命名方式"></a>代码美学与命名方式</h2><h3 id="避免晦涩"><a href="#避免晦涩" class="headerlink" title="避免晦涩"></a>避免晦涩</h3><p>可能各种语言都有不同的命名规范，譬如<code>Rust</code>的变量是使用蛇式（<code>snake_case</code>），而<code>Dart</code>使用的是小驼峰式（<code>camelCase</code>）</p><p>在遵循一种命名规范下，我们的变量名称应该避开使用单个小写字母，以及避开过度缩写，这样我们的变量名称才不会过于晦涩难懂</p><p>你可能会想，平时看到的代码中往往会用 <code>i</code>、<code>j</code>、<code>k</code> 来指代各种的值，这难道是错的吗？这种单个字母的命名来源于数学，早期计算机与数学密切相关，譬如一个二元一次方程 $y=3x^2+2x+1$ ，如果用代码表示</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">i32</span> = ...<br><span class="hljs-keyword">let</span> y = <span class="hljs-number">3</span> * x.pow(<span class="hljs-number">2</span>) + <span class="hljs-number">2</span> * x + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>数学家们似乎很喜欢使用这种方法命名，这种变量名称的确很简洁很酷，但适合数学家的不一定适合程序员，用不那么数学的方法来改写，那么就是下面这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> argument: <span class="hljs-built_in">i32</span> = ...<br><span class="hljs-keyword">let</span> answer = <span class="hljs-number">3</span> * argument.pow(<span class="hljs-number">2</span>) + <span class="hljs-number">2</span> * argument + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>可能你会觉得这没什么，确实没什么，在这里仅仅是2行代码，无论是<code>x</code>与<code>argument</code>还是<code>y</code>与<code>answer</code>都无所谓，试想如果是一个复杂的公式求解函数，大段的<code>x</code>与<code>y</code>此时就会略显突兀，与运算符号同样宽的变量看起来就是点阵图，再加上有些人没有使用代码格式化工具的习惯，那么这段代码就是灾难了，把可读性降到极低的方法叫混淆，在拥有同样功能性能的两份代码之中，选择可读性较高的一种并非没有道理</p><h3 id="约定俗成"><a href="#约定俗成" class="headerlink" title="约定俗成"></a>约定俗成</h3><p>什么叫约定俗成，那便是有大部分人认可的一些变量命名方式</p><p>如果你接触过<code>Python</code>，那你应该会知道诸如<code>args</code>、<code>kwargs</code>的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">*args,**kwargs</span>):</span><br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p><code>args</code>是<code>argument</code>的缩写，<code>kwargs</code>是<code>keyword arguments</code>的缩写，这些东西都是人们所认可的，不必说也能够理解</p><p>简单列举几个缩写（仅供参考）</p><table><thead><tr><th>名称</th><th>缩写</th></tr></thead><tbody><tr><td>answer</td><td>ans</td></tr><tr><td>temporary</td><td>tmp</td></tr><tr><td>database</td><td>db</td></tr><tr><td>function</td><td>func</td></tr><tr><td>pointer</td><td>ptr</td></tr></tbody></table><p>还是那段二元一次方程，使用缩写后</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">let</span> arg: <span class="hljs-built_in">i32</span> = ...<br><span class="hljs-keyword">let</span> ans = <span class="hljs-number">3</span> * arg.pow(<span class="hljs-number">2</span>) + <span class="hljs-number">2</span> * arg + <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="保持简洁"><a href="#保持简洁" class="headerlink" title="保持简洁"></a>保持简洁</h3><p>在早期计算机编程中，在一个庞大的项目中确定一个变量的类型是十分麻烦的，匈牙利命名法就是为了解决这个类型诞生的，简单来说用法就是 <code>类型缩写+大写开头变量名称</code> ，下面是几个例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">int</span> iAge;<span class="hljs-comment">// int</span><br><span class="hljs-keyword">char</span> szName[];<span class="hljs-comment">// char</span><br></code></pre></td></tr></table></figure><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C#"><span class="hljs-keyword">interface</span> <span class="hljs-title">IAnimal</span> &#123;&#125; <span class="hljs-comment">// interface</span><br></code></pre></td></tr></table></figure><p>笔者曾经就对 <code>Java</code> 中的接口要不要使用 <code>I</code> 开头而纠结过，究其原因其实就是为什么要加，加了有什么好处，像 <code>C#</code> 的官方文档之中，命名接口也使用了匈牙利命名法，那么遵守官方文档的规范或许是一个好的选择，但如果没有官方文档呢？</p><p>现代编程工具查看一个变量的类型是非常便利的，那让变量前面加个类型缩写也就没那么重要了，你已经事先知道<code>Animal</code>是一个接口了，那究竟是什么驱使你加上那几个字母，就像StackOverflow上的一句话</p><blockquote><p>The times of the Hungarian notation have passed</p></blockquote><p>对于现代编程，一个更好更简洁的命名法能够让你的代码看上去更漂亮</p><p>但也不是说不要用匈牙利命名法，就像<code>C#</code>中的接口命名一样，如果事先有一个规范，那么去遵守，大胆去用就对了，匈牙利命名法还适用于涉及WinAPI的C/C++编程</p><h2 id="代码美学与类型注释"><a href="#代码美学与类型注释" class="headerlink" title="代码美学与类型注释"></a>代码美学与类型注释</h2><p>现在有很多的编程语言拥有强大的类型系统，这些类型系统应用得当可以帮助我们更好的调用方法，这个例子很容易说明</p><p>在<code>Python</code>中，下面2个函数的不同之处是有意义的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        <span class="hljs-keyword">return</span> self.name<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_animal_name</span>(<span class="hljs-params">animal</span>):</span><br>    <span class="hljs-keyword">return</span> animal.get_name()<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_animal_name</span>(<span class="hljs-params">animal: Animal</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>    <span class="hljs-keyword">return</span> animal.get_name()<br></code></pre></td></tr></table></figure><p>由于<code>Python</code>是一门动态类型的语言，当你调用上面这个函数时，由于没有给出确切的类型，他不会告诉你返回什么，输入什么</p><p><img src="https://raw.githubusercontent.com/H2Sxxa/Blog-ImageGallery/main/picture/image-20240104203459309.png" alt="image-20240104203459309"></p><p>而下面这个函数给出了确切的类型注解，因此你可以放心的传入一个<code>Animal</code>并使用返回的<code>str</code>类型</p><p><img src="https://raw.githubusercontent.com/H2Sxxa/Blog-ImageGallery/main/picture/image-20240104203552056.png" alt="image-20240104203552056"></p><p>因此，我认为，类型系统其实也能算作注释或文档的一部分，如果你有一个拥有明确目的的函数名和确切的类型，删除一部分的多余的注释是完全没有问题的</p><p>此时再来重写一下之前那段寻找最小值的代码 </p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">find_min_index</span></span>(vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> current_index: <span class="hljs-built_in">usize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ans_index: <span class="hljs-built_in">usize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> min: <span class="hljs-built_in">i32</span> = <span class="hljs-built_in">i32</span>::MAX;<br>    <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> vec &#123;<br>        <span class="hljs-keyword">if</span> v &lt; min &#123;<br>            min = v;<br>            ans_index = current_index;<br>        &#125;<br>        current_index += <span class="hljs-number">1</span>;<br>    &#125;<br>    ans_index<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="代码美学与编程范式"><a href="#代码美学与编程范式" class="headerlink" title="代码美学与编程范式"></a>代码美学与编程范式</h2><h3 id="函数式编程与代码扁平化"><a href="#函数式编程与代码扁平化" class="headerlink" title="函数式编程与代码扁平化"></a>函数式编程与代码扁平化</h3><p>对于很多人来说，函数式编程看起来遥远实则相近，大部分的语言如今都或多或少支持一部分的函数式编程，你可能在用，但你不知道这就是函数式编程，像<code>Python</code>里的<code>lambda</code>、<code>map</code>、<code>filter</code>，<code>Java</code>的<code>java.util.function</code>下的<code>Consumer</code>、<code>Supplier</code>、<code>Predicate</code>、<code>Function</code>都是属于函数式编程的范畴之内，更不必提<code>Haskell</code>、<code>ML</code>、<code>Scala</code>这些以函数式而出名的语言，如果你对函数式编程感兴趣可以自行去了解，这不属于本篇文章的范畴，函数式编程有什么好处？暂且不提开发效率，使用函数式编程会大大减少代码的嵌套，也就是<strong>代码扁平化</strong></p><p>再次来重写一下上面的这段代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">find_min_index</span></span>(vec: <span class="hljs-built_in">Vec</span>&lt;<span class="hljs-built_in">i32</span>&gt;) -&gt; <span class="hljs-built_in">usize</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> ans_index: <span class="hljs-built_in">usize</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut</span> min: <span class="hljs-built_in">i32</span> = <span class="hljs-built_in">i32</span>::MAX;<br><br>    vec.into_iter()<br>        .enumerate()<br>        .for_each(|(current_index, value)| &#123;<br>            <span class="hljs-keyword">if</span> value &lt; min &#123;<br>                min = value;<br>                ans_index = current_index;<br>            &#125;<br>        &#125;);<br><br>    ans_index<br>&#125;<br></code></pre></td></tr></table></figure><p>代码扁平化还有另一种方法那就是提取内层嵌套为一个函数，这种方法并不难理解也不过多阐述</p><h3 id="面向对象编程与设计模式"><a href="#面向对象编程与设计模式" class="headerlink" title="面向对象编程与设计模式"></a>面向对象编程与设计模式</h3><p>设计模式是什么，其实就是一系列代码的最佳实践，至于和面向对象放在一起，那是因为<code>Java</code>的设计模式往往是属于比较出名的那个，而<code>Java</code>又是典型的面向对象语言</p><h4 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h4><p>设计模式往往与抽象有关，因此知道什么是抽象实际上是必要的，什么是抽象？抽象是从几个具体的事物抽离相似的部分，简单地从一段代码实例来说</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drink</span>(<span class="hljs-params">self</span>):</span> ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span>(<span class="hljs-params">self</span>):</span> ...<br>    ...<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drink</span>(<span class="hljs-params">self</span>):</span> ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span>(<span class="hljs-params">self</span>):</span> ...<br>    ...<br></code></pre></td></tr></table></figure><p>可以看到<code>Pig</code>和<code>Dog</code>拥有相同的特征，<code>eat</code>和<code>drink</code>，把共同的特征抽离出来就是<code>Animal</code>，这就是一个抽象，此外，我们还可以把<code>Animal</code>定义为一个抽象类（Abstract Class）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span>(<span class="hljs-params">ABC</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">drink</span>(<span class="hljs-params">self</span>):</span> ...<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">eat</span>(<span class="hljs-params">self</span>):</span> ...<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>(<span class="hljs-params">Animal</span>):</span>...<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span>(<span class="hljs-params">Animal</span>):</span>...<br></code></pre></td></tr></table></figure><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://zhuanlan.zhihu.com/p/89909623">四种基本的编程命名规范 - 知乎</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://learn.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/interface">C#官方文档中的接口</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span><a href="https://stackoverflow.com/a/41967120/4676238">Confused about the Interface and Class coding guidelines for TypeScript(StackOverflow)</a><a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Code Aesthetic</tag>
      
      <tag>Rust</tag>
      
      <tag>Python</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈面向对象与面向过程</title>
    <link href="/2023/09/17/about_oo_and_po/"/>
    <url>/2023/09/17/about_oo_and_po/</url>
    
    <content type="html"><![CDATA[<h1 id="浅谈面向对象与面向过程"><a href="#浅谈面向对象与面向过程" class="headerlink" title="浅谈面向对象与面向过程"></a>浅谈面向对象与面向过程</h1><p>本人阅历有限，本篇博客如有错误请不吝指出，也欢迎在下方发布你的看法。</p><h2 id="面向对象（OO）"><a href="#面向对象（OO）" class="headerlink" title="面向对象（OO）"></a>面向对象（OO）</h2><h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>对象是什么这个问题曾经困惑了我许久，Rust的<code>struct</code>和Python的<code>class</code>都能够实现一个对象，有人说对象是一个属性和方法集的融合体，也有人说面向对象三大基本特征在于封装，继承，多态，多态和继承都是对于子类和父类关系来说，Rust里没有很好的方法来实现这2个特性，在现代编程中组合优于继承，所以我认为对象最基本的特征还是在于是否可实例化和封装。</p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>例如定义一个生物的类</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">Living</span></span> &#123;<br>    name: <span class="hljs-built_in">String</span>, <span class="hljs-comment">// 私有属性，不是pub name，用于封装name</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> Living &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">new</span></span>(name: &amp;<span class="hljs-built_in">str</span>) -&gt; <span class="hljs-keyword">Self</span> &#123;<br>        <span class="hljs-keyword">Self</span> &#123;<br>            name: name.to_string(),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">get_name</span></span>(&amp;<span class="hljs-keyword">self</span>) -&gt; <span class="hljs-built_in">String</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.name.clone();<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">set_name</span></span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, name: &amp;<span class="hljs-built_in">str</span>) &#123;<br>        <span class="hljs-keyword">self</span>.name = name.to_string();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Living</span>:</span><br>    __name:<span class="hljs-built_in">str</span> <span class="hljs-comment"># 会把这个变量转化为 _Living__name，无法通过__name访问，实现封装</span><br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,name:<span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        self.__name = name<br>        <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_name</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        <span class="hljs-keyword">return</span> self.__name<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_name</span>(<span class="hljs-params">self,name:<span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:</span><br>        self.__name = name<br></code></pre></td></tr></table></figure><p>在上述2段代码中，我们都对<code>name</code>做了私有化处理，并且定义了2个方法<code>get_name</code>和<code>set_name</code>，这是很经典的封装，这两个方法叫做<code>getter</code>和<code>setter</code>，但很多情况下，我们也无需强制自己把所有成员属性私有化并且加上<code>getter</code>和<code>setter</code>，这是很死的做法。</p><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><p>实例化就是把一类东西转化为一种东西（这个东西是前面的东西的一个例子，例如<code>human</code>是<code>Living</code>的一个例子），后者相比前者往往范围更小更精确，还是刚才那个<code>Living</code>，让我们实例化一种名为<code>human</code>的生物，在很多语言中<code>new</code>是作为实例化的关键字，Python的<code>class</code>有2个魔法方法，分别是<code>__init__</code>和<code>__new__</code>，通过字面意思理解，前者是初始化，后者是实例化，C++和Java都有构造函数且都是在<code>new</code>时被调用（不考虑C++的其他实例化方法）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-function"><span class="hljs-keyword">fn</span> <span class="hljs-title">main</span></span>()&#123;<br>    <span class="hljs-keyword">let</span> human = Living::new(<span class="hljs-string">&quot;human&quot;</span>); <span class="hljs-comment">// 人是有名字的生物的一种实例</span><br>    human.set_name(<span class="hljs-string">&quot;human_i&quot;</span>);<br>    <span class="hljs-built_in">print!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,human.get_name())<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">human = Living(<span class="hljs-string">&quot;human&quot;</span>)<br>human.set_name(<span class="hljs-string">&quot;human_i&quot;</span>)<br><span class="hljs-built_in">print</span>(human.get_name())<br></code></pre></td></tr></table></figure><p>上面2段运行结果都是输出<code>human_i</code>，我们可以看得出来<code>Living</code>的实例有能力为你保存一个<code>name</code>的属性，并且通过内置方法来控制。</p><h2 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h2><p>我接触的面向过程的语言不多，目前只有C，虽然说可以通过其他语言的多范式编程来实现面向过程，那未免有点不地道。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>有过程就必然有结果，下方是一个求字符串长度的例子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span> <span class="hljs-keyword">const</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> x[] = <span class="hljs-string">&quot;string&quot;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%i\n&quot;</span>, (<span class="hljs-keyword">int</span>) <span class="hljs-built_in">strlen</span>(x));<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为我们对<code>x</code>使用了<code>strlen</code>，<code>strlen</code>是一个求解过程，所以得到了<code>6</code>这个结果，这看起来远没有面向对象复杂。</p><h2 id="面向对象的语言与面向过程的语言对比"><a href="#面向对象的语言与面向过程的语言对比" class="headerlink" title="面向对象的语言与面向过程的语言对比"></a>面向对象的语言与面向过程的语言对比</h2><p>还是求字符串长度的例子，Python是一门可以进行面向对象的语言，<code>str</code>是一类，<code>str()</code>/<code>&quot;string&quot;</code>都是<code>str</code>的实例，如果我们用面向对象的方法来求字符串长度那就是<code>&quot;string&quot;.__len__()</code>，如果面向过程，那就是<code>len(&quot;string&quot;)</code>，在C里我们用的是后者这种写法，其中的不同，还是很明显的。</p>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>Python</tag>
      
      <tag>C</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在VSCode里通过WSL进行C的开发</title>
    <link href="/2023/08/10/wsl_c_dev_vscode/"/>
    <url>/2023/08/10/wsl_c_dev_vscode/</url>
    
    <content type="html"><![CDATA[<h2 id="我只想看看怎么配置MinGW"><a href="#我只想看看怎么配置MinGW" class="headerlink" title="我只想看看怎么配置MinGW"></a>我只想看看怎么配置MinGW</h2><p>MinGW全称是Minimalist GNU on Windows，翻译一下就是<strong>用于Windows的简单GNU套件</strong>，里面不仅包含了mingw-gcc/g++用于编译C/C++文件，还包含了许多头文件以及bison，make等工具，可以让你在Windows上轻松开发C/C++程序。</p><p>如果你不想使用WSL，你可以参考 <a href="https://code.visualstudio.com/docs/cpp/config-mingw">Get Started with C++ and MinGW-w64 in Visual Studio Code</a> 这篇文章来为你的VSCode配置MinGW。</p><h2 id="什么是WSL"><a href="#什么是WSL" class="headerlink" title="什么是WSL"></a>什么是WSL</h2><p>WSL的全称是Windows Subsystem for Linux，也就是Windows Linux子系统，在 Windows 10.1607 后存在于Windows系统中。</p><blockquote><p>适用于 Linux 的 Windows 子系统可让开发人员按原样运行 GNU/Linux 环境 - 包括大多数命令行工具、实用工具和应用程序 - 且不会产生传统虚拟机或双启动设置开销。</p><p>–  <a href="https://learn.microsoft.com/zh-cn/windows/wsl/about">什么是适用于 Linux 的 Windows 子系统 | Microsoft Learn</a></p></blockquote><p>同样提供一份官方教程 <a href="https://code.visualstudio.com/docs/cpp/config-wsl">Get Started with C++ and Windows Subsystem for Linux in Visual Studio Code</a></p><h2 id="为什么是WSL"><a href="#为什么是WSL" class="headerlink" title="为什么是WSL"></a>为什么是WSL</h2><p>总而言之就是Windows开发体验太蚌埠了<del>(说的就是你MSVC)</del>，而Linux好很多，而且软件包管理起来也很方便。</p><h3 id="我想要让我的程序给Windows用啊！"><a href="#我想要让我的程序给Windows用啊！" class="headerlink" title="我想要让我的程序给Windows用啊！"></a>我想要让我的程序给Windows用啊！</h3><p>WSL里的C编译器编译出来仅能提供给相同平台架构的机器使用，如果你需要多平台，你可以尝试交叉编译，也可以用类似于Github Action的CI来进行编译，总之方法有很多，这个问题随着你的深入会很简单。</p><p>补记有关于如何在WSL进行交叉编译可以供你简单参考。</p><p>那么我们开始吧！</p><h2 id="前置步骤"><a href="#前置步骤" class="headerlink" title="前置步骤"></a>前置步骤</h2><p>为了确保你的WSL功能可用我们用命令行先把功能打开</p><h3 id="开启WSL和虚拟化"><a href="#开启WSL和虚拟化" class="headerlink" title="开启WSL和虚拟化"></a>开启WSL和虚拟化</h3><p>使用<strong>管理员身份</strong>打开PowerShell输入</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs powershell">dism.exe /online /<span class="hljs-built_in">enable-feature</span> /featurename:Microsoft<span class="hljs-literal">-Windows</span><span class="hljs-literal">-Subsystem</span><span class="hljs-literal">-Linux</span> /all /norestart<br>dism.exe /online /<span class="hljs-built_in">enable-feature</span> /featurename:VirtualMachinePlatform /all /norestart<br></code></pre></td></tr></table></figure><p>然后重启一下电脑，可能会进行系统更新w</p><h3 id="升级WSL内核"><a href="#升级WSL内核" class="headerlink" title="升级WSL内核"></a>升级WSL内核</h3><p>电脑默认是WSL1内核，我们把它升级到WSL2，以防出现<code>0x800701bc</code>错误。</p><p><a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi">点击这里获取WSL升级安装包</a></p><p>安装升级后，打开PowerShell输入<code>wsl --set-default-version 2</code>，然后就大功告成了！（也可以不输，似乎默认就是WSL2了现在）</p><h2 id="安装WSL的Linux分发版"><a href="#安装WSL的Linux分发版" class="headerlink" title="安装WSL的Linux分发版"></a>安装WSL的Linux分发版</h2><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">微软提供的教程</a></p><h3 id="微软商店安装"><a href="#微软商店安装" class="headerlink" title="微软商店安装"></a>微软商店安装</h3><p>如果安装Ubuntu（WSL）直接在微软商店搜索Ubuntu即可，直接安装就行了。</p><p>安装完后打开PowerShell输入<code>wsl --install</code>确保安装完整即可。</p><p>全部结束后记得<code>wsl -l -v</code>看看是否安装成功（当然也可以不看❌）。</p><h3 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h3><p>使用下方这行命令可以列出所有可用的 Linux 发行版本（不含一些第三方版本），默认是Ubuntu，我也推荐安装Ubuntu，比较省事。</p><p><del>当然如果你想要折腾也可以去找个ArchLinux</del></p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl <span class="hljs-literal">-l</span> <span class="hljs-literal">-o</span><br><span class="hljs-comment"># wsl --list --online</span><br><span class="hljs-comment">#以下是可安装的有效分发的列表。</span><br><span class="hljs-comment">#使用 &#x27;wsl.exe --install &lt;Distro&gt;&#x27; 安装。</span><br><br><span class="hljs-comment">#NAME                                   FRIENDLY NAME</span><br><span class="hljs-comment">#Ubuntu                                 Ubuntu</span><br><span class="hljs-comment">#Debian                                 Debian GNU/Linux</span><br><span class="hljs-comment">#kali-linux                             Kali Linux Rolling</span><br><span class="hljs-comment">#Ubuntu-18.04                           Ubuntu 18.04 LTS</span><br><span class="hljs-comment">#Ubuntu-20.04                           Ubuntu 20.04 LTS</span><br><span class="hljs-comment">#Ubuntu-22.04                           Ubuntu 22.04 LTS</span><br><span class="hljs-comment">#OracleLinux_7_9                        Oracle Linux 7.9</span><br><span class="hljs-comment">#OracleLinux_8_7                        Oracle Linux 8.7</span><br><span class="hljs-comment">#OracleLinux_9_1                        Oracle Linux 9.1</span><br><span class="hljs-comment">#openSUSE-Leap-15.5                     openSUSE Leap 15.5</span><br><span class="hljs-comment">#SUSE-Linux-Enterprise-Server-15-SP4    SUSE Linux Enterprise Server 15 SP4</span><br><span class="hljs-comment">#SUSE-Linux-Enterprise-15-SP5           SUSE Linux Enterprise 15 SP5</span><br><span class="hljs-comment">#openSUSE-Tumbleweed                    openSUSE Tumbleweed</span><br></code></pre></td></tr></table></figure><p>输入这行就会自动开始安装WSL了</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">wsl -<span class="hljs-literal">-install</span> <span class="hljs-literal">-d</span> Ubuntu<br></code></pre></td></tr></table></figure><h3 id="配置账户密码"><a href="#配置账户密码" class="headerlink" title="配置账户密码"></a>配置账户密码</h3><p><a href="https://learn.microsoft.com/zh-cn/windows/wsl/setup/environment#set-up-your-linux-username-and-password">微软的教程</a></p><p>运行刚才安装好的Ubuntu，或者直接Powershell里运行<code>wsl</code>，然后就是首次启动配置账户密码了，输入密码的时候，<strong>终端不会有任何符号输出</strong>，切记要保管好自己的账户密码，不然后面sudo的时候忘记就难受了。</p><h2 id="选择你的编译器"><a href="#选择你的编译器" class="headerlink" title="选择你的编译器"></a>选择你的编译器</h2><p>编译器简单来说就是将源代码经过一系列处理变为二进制文件的一个软件，如果你想了解更多，请查看编译原理</p><p>C的编译器有很多，主流的有GCC，Clang，MSVC，而GCC是跨平台的，MSVC是Windows独享<del>（都叫MicroSoft Visual C/C++了）</del>，Clang的编译只能在Linux/MacOS这些平台使用</p><p>在本教程中你可以选择安装GCC或Clang，Clang虽然比GCC相比有很多优点（速度快，占用小），但是可能需要再折腾，在大部分的C语言指导书里普遍使用的是GCC，如果你是一个Newer，在没有把握的前提下，我推荐你使用GCC而不是Clang</p><h3 id="GCC"><a href="#GCC" class="headerlink" title="GCC"></a>GCC</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo sed -i <span class="hljs-string">&#x27;s/http:\/\/cn.archive.ubuntu.com/https:\/\/mirror.sjtu.edu.cn/g&#x27;</span> /etc/apt/sources.lis <span class="hljs-comment">#切换SJTU镜像 https://mirror.sjtu.edu.cn/docs/ubuntu</span><br>sudo apt update -y <span class="hljs-comment">#更新软件包清单</span><br>sudo apt upgrade -y <span class="hljs-comment">#升级软件包</span><br>sudo apt-get install build-essential gdb<br></code></pre></td></tr></table></figure><p>安装完后请检查安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">whereis g++<br>whereis gdb<br></code></pre></td></tr></table></figure><h3 id="Clang"><a href="#Clang" class="headerlink" title="Clang"></a>Clang</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo sed -i <span class="hljs-string">&#x27;s/http:\/\/cn.archive.ubuntu.com/https:\/\/mirror.sjtu.edu.cn/g&#x27;</span> /etc/apt/sources.list <span class="hljs-comment">#切换SJTU镜像，详见 https://mirror.sjtu.edu.cn/docs/ubuntu</span><br>sudo apt update -y <span class="hljs-comment">#更新软件包清单</span><br>sudo apt upgrade -y <span class="hljs-comment">#升级软件包</span><br>sudo apt-get install clang clangd lldb cmake<br></code></pre></td></tr></table></figure><p>安装完后请检查安装</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">whereis clang<br>whereis clangd<br>whereis lldb<br>whereis cmake<br></code></pre></td></tr></table></figure><p>如果你愿意可以选择再装一个build-essential，以后可能会用到</p><h2 id="安装VSCode"><a href="#安装VSCode" class="headerlink" title="安装VSCode"></a>安装VSCode</h2><p>请认准 <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a> 下载</p><p>如果下的太慢可以扔进去这个链接下载 <a href="https://d.serctl.com/">https://d.serctl.com/</a> 或者自寻安装包</p><h3 id="安装VSCode插件"><a href="#安装VSCode插件" class="headerlink" title="安装VSCode插件"></a>安装VSCode插件</h3><p>如果你需要中文的VSCode，你可以安装一个Chinese (Simplified)插件</p><p>当你准备好后，安装一个 WSL 插件，然后点击位于左下角的打开远程窗口选择<code>连接到WSL</code></p><p>之后就可以安装C/C++的插件</p><p>下面是我推荐的插件(不包含make插件)</p><ul><li>C/C++<ul><li>Clangd依赖于此</li></ul></li><li>Clangd<ul><li>代码分析提示</li></ul></li><li>Code Runner<ul><li>C/C++ Runner运行有点纸张，建议用这个运行，不支持调试</li></ul></li><li>C/C++ Runner<ul><li>建议只用于调试</li></ul></li><li>CodeLLDB<ul><li>C/C++ Runner依赖于此</li></ul></li></ul><p>下面这些不是必须的，但是可以改进体验</p><ul><li>VSCodeSnap<ul><li>截图插件</li></ul></li><li>C/C++ Snippets<ul><li>代码模板</li></ul></li><li>FiraCode<ul><li>连字字体</li></ul></li><li>Error Lens<ul><li>改进错误信息的外观</li></ul></li></ul><h3 id="开始开发"><a href="#开始开发" class="headerlink" title="开始开发"></a>开始开发</h3><p>你需要先在你的 home 目录新建一个英文文件夹用于存放你的源代码，然后用VSCode连接到WSL打开此文件夹即可。</p><p>打开文件夹后，新建<code>main.c</code>或者叫<code>test.c</code>什么样都可以，但不要使用中文名称，之后就可以开始你的编写了！</p><h2 id="补记：交叉编译"><a href="#补记：交叉编译" class="headerlink" title="补记：交叉编译"></a>补记：交叉编译</h2><h3 id="交叉编译是什么"><a href="#交叉编译是什么" class="headerlink" title="交叉编译是什么"></a>交叉编译是什么</h3><p>简单来说，就是跨平台编译，从平台A编译平台B可以用的二进制文件，这里的平台包括但不限于系统架构（x86-64,aarch64……），操作系统（Windows，Linux……）。</p><h3 id="WSL交叉编译Windows可执行程序"><a href="#WSL交叉编译Windows可执行程序" class="headerlink" title="WSL交叉编译Windows可执行程序"></a>WSL交叉编译Windows可执行程序</h3><h4 id="安装MinGW"><a href="#安装MinGW" class="headerlink" title="安装MinGW"></a>安装MinGW</h4><p>只需一行命令即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install mingw-w64<br></code></pre></td></tr></table></figure><p>安装结束后，使用以下命令检查安装。</p><ul><li><p>i686对于32位系统</p></li><li><p>x86_64对应64位系统</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">whereis i686-w64-mingw32-gcc<br>whereis i686-w64-mingw32-g++<br>whereis x86_64-w64-mingw32-gcc<br>whereis x86_64-w64-mingw32-g++<br></code></pre></td></tr></table></figure><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>示例：如果我需要编译一个Windows x64的可执行文件只需<code>x86_64-w64-mingw32-gcc -o 输出文件路径.exe 源代码路径.c</code></p><h2 id="后记：解决Math-h无法引用"><a href="#后记：解决Math-h无法引用" class="headerlink" title="后记：解决Math.h无法引用"></a>后记：解决<code>Math.h</code>无法引用</h2><p><a href="https://nanodaovo.github.io/2023/10/19/debug-mathh">详见这位的博客，点击即可跳转</a></p>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>WSL</tag>
      
      <tag>Linux</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Forge镜像补全计划（教程向）</title>
    <link href="/2023/07/16/forge_dev_gradlemirror/"/>
    <url>/2023/07/16/forge_dev_gradlemirror/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这个教程旨在教你使构建环境完全在镜像下运行，摆脱对代理的依赖。</p><h1 id="更换Gradle下载地址"><a href="#更换Gradle下载地址" class="headerlink" title="更换Gradle下载地址"></a>更换Gradle下载地址</h1><p>Gradle本体的下载地址位于<code>项目文件夹\gradle\wrapper\gradle-wrapper.properties</code>中。</p><p>打开<code>gradle-wrapper.properties</code>，你会看到类似以下的文本</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">distributionBase=GRADLE_USER_HOME<br>distributionPath=<span class="hljs-keyword">wrapper</span>/dists<br>distributionUrl=https\://services.gradle.org/distributions/gradle<span class="hljs-number">-8.1</span><span class="hljs-number">.1</span>-bin.zip<br>zipStoreBase=GRADLE_USER_HOME<br>zipStorePath=<span class="hljs-keyword">wrapper</span>/dists<br></code></pre></td></tr></table></figure><p>把<code>services.gradle.org/distributions</code>换成<code>mirrors.cloud.tencent.com/gradle</code>，也就是这样。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">distributionBase=GRADLE_USER_HOME<br>distributionPath=<span class="hljs-keyword">wrapper</span>/dists<br>distributionUrl=https\://mirrors.cloud.tencent.com/gradle/gradle<span class="hljs-number">-8.1</span><span class="hljs-number">.1</span>-bin.zip<br>zipStoreBase=GRADLE_USER_HOME<br>zipStorePath=<span class="hljs-keyword">wrapper</span>/dists<br></code></pre></td></tr></table></figure><p>注意：示例中的<code>gradle-8.1.1-bin.zip</code>取决于你自己<code>gradle-wrapper.properties</code>，没有把握请勿随便更改！</p><h1 id="ROSA"><a href="#ROSA" class="headerlink" title="ROSA"></a>ROSA</h1><p>下载地址 <a href="https://github.com/H2Sxxa/Rosa/releases/latest">https://github.com/H2Sxxa/Rosa/releases/latest</a></p><p>镜像测试的报告 <a href="https://github.com/H2Sxxa/Rosa/blob/bin/forgegradle/class/TEST_REPORT.md">https://github.com/H2Sxxa/Rosa/blob/bin/forgegradle/class/TEST_REPORT.md</a></p><p>下载后配置好它的镜像修补就行，教程看Rosa首页的图片教程</p><p>（PS:觉得好用不妨给项目点个Star）</p><h1 id="新版-Gradle"><a href="#新版-Gradle" class="headerlink" title="新版 Gradle"></a>新版 Gradle</h1><p>要改的地方一共有3个，这3个文件都在项目文件夹下</p><h2 id="gradle-properties（如果没有可以直接新建一个gradle-properties然后添加保存）"><a href="#gradle-properties（如果没有可以直接新建一个gradle-properties然后添加保存）" class="headerlink" title="gradle.properties（如果没有可以直接新建一个gradle.properties然后添加保存）"></a>gradle.properties（如果没有可以直接新建一个gradle.properties然后添加保存）</h2><p>将这一段直接加在最下面</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># mirror</span><br><span class="hljs-attr">use_mirror</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment"># BMCLAPI is unstable sometimes, use lss233&#x27;s mirror for alternative.</span><br><span class="hljs-comment">#mirror_maven_url=bmclapi2.bangbang93.com/maven</span><br><span class="hljs-comment">#mirror_maven_url=crystal.app.lss233.com/repositories/minecraft</span><br><span class="hljs-attr">mirror_maven_url</span>=download.mcbbs.net/maven<br></code></pre></td></tr></table></figure><h2 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs groovy">pluginManagement &#123;<br>    repositories &#123;<br>        <span class="hljs-comment">//......原来的东西不要动，把以下内容添加</span><br>        <span class="hljs-keyword">if</span> (use_mirror.toBoolean()) &#123;<br>            removeIf &#123;<br>                it <span class="hljs-keyword">instanceof</span> MavenArtifactRepository &amp;&amp;<br>                    (it.url.toString() == <span class="hljs-string">&quot;https://repo.maven.apache.org/maven2/&quot;</span>)<br>            &#125;<br>            maven &#123;<br>                name <span class="hljs-string">&#x27;Ali Mirror Maven&#x27;</span><br>                url <span class="hljs-string">&quot;https://maven.aliyun.com/nexus/content/groups/public&quot;</span><br>                allowInsecureProtocol = <span class="hljs-literal">true</span><br>            &#125;<br>            maven &#123;<br>                name <span class="hljs-string">&#x27;MC Mirror Maven&#x27;</span><br>                url <span class="hljs-string">&quot;https://$&#123;mirror_maven_url&#125;&quot;</span><br>                allowInsecureProtocol = <span class="hljs-literal">true</span><br>            &#125;<br>            <span class="hljs-comment">//more mirror maven add here,in order to search plugins</span><br>        &#125;<br><span class="hljs-comment">//截止到这里，必须要在这几个东西上面，下面这些东西请勿一并添加</span><br>        gradlePluginPortal()<br>        mavenLocal()<br>        mavenCentral()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs groovy">repositories &#123;<br>    <span class="hljs-comment">//......原来的东西不要动，把以下内容添加</span><br>    <span class="hljs-keyword">if</span> (project.use_mirror.toBoolean()) &#123;<br>        removeIf &#123;<br>            it <span class="hljs-keyword">instanceof</span> MavenArtifactRepository &amp;&amp;<br>                (it.url.toString() == <span class="hljs-string">&quot;https://repo.maven.apache.org/maven2/&quot;</span>)<br>        &#125;<br>        maven &#123;<br>            name <span class="hljs-string">&#x27;Ali Mirror Maven&#x27;</span><br>            url <span class="hljs-string">&quot;https://maven.aliyun.com/nexus/content/groups/public&quot;</span><br>            allowInsecureProtocol = <span class="hljs-literal">true</span><br>        &#125;<br>        maven &#123;<br>            name <span class="hljs-string">&#x27;MC Mirror Maven&#x27;</span><br>            url <span class="hljs-string">&quot;https://$&#123;mirror_maven_url&#125;&quot;</span><br>            allowInsecureProtocol = <span class="hljs-literal">true</span><br>        &#125;<br>        <span class="hljs-comment">//more mirror maven add here,in order to search plugins</span><br>    &#125;<br>    <span class="hljs-comment">//截止到这里，必须要在这几个东西上面，下面这些东西请勿一并添加</span><br>    mavenLocal() <span class="hljs-comment">// Must be last for caching to work</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="旧版-Gradle"><a href="#旧版-Gradle" class="headerlink" title="旧版 Gradle"></a>旧版 Gradle</h1><p>要改的地方一共有2个，这2个文件都在项目文件夹下</p><h2 id="gradle-properties（如果没有可以直接新建一个gradle-properties然后添加保存）-1"><a href="#gradle-properties（如果没有可以直接新建一个gradle-properties然后添加保存）-1" class="headerlink" title="gradle.properties（如果没有可以直接新建一个gradle.properties然后添加保存）"></a>gradle.properties（如果没有可以直接新建一个gradle.properties然后添加保存）</h2><p>将这一段直接加在最下面</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># mirror</span><br><span class="hljs-attr">use_mirror</span> = <span class="hljs-literal">true</span><br><span class="hljs-comment"># BMCLAPI is unstable sometimes, use lss233&#x27;s mirror for alternative.</span><br><span class="hljs-comment">#mirror_maven_url=bmclapi2.bangbang93.com/maven</span><br><span class="hljs-comment">#mirror_maven_url=crystal.app.lss233.com/repositories/minecraft</span><br><span class="hljs-attr">mirror_maven_url</span>=download.mcbbs.net/maven<br></code></pre></td></tr></table></figure><h2 id="build-gradle-1"><a href="#build-gradle-1" class="headerlink" title="build.gradle"></a>build.gradle</h2><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs groovy">buildscript &#123;<br>    <span class="hljs-comment">//只需要改repositories里的内容</span><br>    repositories &#123;<br>        <span class="hljs-keyword">if</span> (use_mirror == <span class="hljs-string">&quot;true&quot;</span>) &#123;<br>        removeIf &#123;<br>            it <span class="hljs-keyword">instanceof</span> MavenArtifactRepository &amp;&amp;<br>                (it.url.toString() == <span class="hljs-string">&quot;https://repo.maven.apache.org/maven2/&quot;</span>)<br>        &#125;<br>            maven &#123; url <span class="hljs-string">&quot;https://maven.aliyun.com/nexus/content/groups/public&quot;</span> &#125;<br>            maven &#123; url <span class="hljs-string">&quot;https://$&#123;mirror_maven_url&#125;&quot;</span> &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mavenCentral()<br>            maven &#123; url <span class="hljs-string">&quot;https://maven.minecraftforge.net&quot;</span> &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//...其他不用管</span><br>&#125;<br><span class="hljs-comment">//...</span><br>repositories &#123; <span class="hljs-comment">// 在这个大括号内添加</span><br>    <span class="hljs-keyword">if</span> (use_mirror == <span class="hljs-string">&quot;true&quot;</span>) &#123;<br>    removeIf &#123;<br>        it <span class="hljs-keyword">instanceof</span> MavenArtifactRepository &amp;&amp;<br>            (it.url.toString() == <span class="hljs-string">&quot;https://repo.maven.apache.org/maven2/&quot;</span>)<br>    &#125;<br>        maven &#123; url <span class="hljs-string">&quot;https://maven.aliyun.com/nexus/content/groups/public&quot;</span> &#125;<br>        maven &#123; url <span class="hljs-string">&quot;https://$&#123;mirror_maven_url&#125;&quot;</span> &#125;<br>    &#125;<br>    <span class="hljs-comment">//...其他不用管</span><br>&#125;<br><span class="hljs-comment">//...</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Forge</tag>
      
      <tag>Groovy</tag>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROSA开发总结</title>
    <link href="/2023/07/11/rosa_dev_exp/"/>
    <url>/2023/07/11/rosa_dev_exp/</url>
    
    <content type="html"><![CDATA[<h1 id="关于ROSA"><a href="#关于ROSA" class="headerlink" title="关于ROSA"></a>关于ROSA</h1><p>ROSA其实并不是我写出来的第一个配置环境的工具，但可能是最后一个，因为ROSA的功能将会完备，不需要再去立项了，这就是所谓的继承前者并拓展，我开发Kekkai的时候也是抱着这种想法。</p><p>为什么叫ROSA？我当初立项的时候想到了一张符卡「Subterranean Rose」，但因为Rose念得不顺口就改成了它的异变体Rosa（笑）。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p><strong>本博客仅代表个人观点，可能有些错误，请自行辨别，欢迎评论指出。</strong></p><h1 id="关于开发中研究"><a href="#关于开发中研究" class="headerlink" title="关于开发中研究"></a>关于开发中研究</h1><p>ROSA镜像修补功能的想法起初是我看到了IDF中炸鸭写的<a href="https://github.com/IdeallandEarthDept/IdeallandFramework/blob/master/mirror.gradle">mirror.gradle</a>，结合了此前知道jar的本质是一个zip，可使用zip的方法对其进行操作，我就想那我重新编译一些class然后注入jar中是不是就可以实现镜像修补？</p><p>我就尝试Fork了FG、RFG并编译，但由于编译失败（后来成功了，但用不上了 X），我与<a href="https://github.com/cdc12345">cdc12345</a>（后文简称cdc）深度讨论研究了一下，他给了我另一种思路，直接提取class来用jbytemod来修改字符串，再重新弄进jar中。</p><h2 id="Gradle生成缓存顺序"><a href="#Gradle生成缓存顺序" class="headerlink" title="Gradle生成缓存顺序"></a>Gradle生成缓存顺序</h2><p>我们都知道Gradle下载的包在<code>.gradle/caches/modules-2/file-2.1</code>中，但<code>.gradle/caches/jar-9</code>中也能找到几倍大于前者的同名jar。</p><p>我又和cdc讨论了一下，他使用工具帮我确定了一下Gradle使用jar位于jar-9中（感谢cdc），我尝试把jar-9给删了，然后重新运行<code>./gradlew</code>，结果是jar-9重新生成了，我就推测jar-9来源于file-2.1，并且在Gradle初始化时生成，事实证明应该我想的没错。</p><p>（后来又研究了一下jar-9的jar为什么体积能达到file-2.1的三倍之多，原因是压缩时算法不同，jar-9可能是使用了STORE模式来压缩（仅存储），而file-2.1（打包jar）则是使用了特定的算法来进行压缩）</p><p>确定了jar的位置，由于我环境里只有FG的分支RFG，所以我首先先对RFG的常量类下手了，天真的我以为只要修改了常量类中的字符串就可以实现jar全局的修改。</p><h2 id="编译的常量与反编译的巨坑"><a href="#编译的常量与反编译的巨坑" class="headerlink" title="编译的常量与反编译的巨坑"></a>编译的常量与反编译的巨坑</h2><p>在我实现修改常量类，写入jar时，我发现p用没有，ok，我以为是程序出了问题，那我自然是手动修改了一下jar中class，发现也是p用没有，我就想，这件事可能没我想的那么简单（1 WEEK AFTER）那我又回去看了看炸鸭老师写的mirror.gradle，我发现他修改的不仅仅是常量类，还涉及到了很多引用常量的类，于是我就随便拆了一个class出来，用记事本打开（标准结局），我发现里面本该引用常量类的地方是一些字符串，那我就明白了，javac在编译这种常量引用的时候会直接使用常量替换引用。</p><p>于是我把所有class都修改了，再手动塞进了jar中，经过测试，的确是成功了。</p><p>看到有所成果，我火速完善了ROSA的镜像修补功能，当我以为这一切都要结束的时候，我发现又出现了一些问题。</p><h2 id="Dart的archive库与7za-exe"><a href="#Dart的archive库与7za-exe" class="headerlink" title="Dart的archive库与7za.exe"></a>Dart的archive库与7za.exe</h2><p>我的解压缩部分都是使用Dart的archive库来编写的，我以为天下的zip除了压缩等级不同，就没有什么区别了，jar能成功被archive解压，也使我确信能够重新打包回jar。</p><p>修补完成后，我运行Gradle命令构建环境，起初是正常进行，但到了后面又爆了<code>不支持的lambda task</code>这类的错误（SEVERAL DAYS AFTER）我经过反反复复的控制变量实验终于搞明白了问题就是出在打包上，于是我研究了一晚上archive库，了解到有zlib压缩，zip压缩……经过对这些东西的尝试，我发现archive问题是真的多啊，各种报错与错误生成……我直接光速放弃寻找替代品。</p><h3 id="感觉不如7za-exe"><a href="#感觉不如7za-exe" class="headerlink" title="感觉不如7za.exe"></a>感觉不如7za.exe</h3><p>由于我之前有过开发压缩软件的经验，我就选择了<code>Process.runSync</code>与7-zip中提取的<code>7za.exe</code>来实行我的解压缩，事实证明这很成功，感觉Windows平台上archive库真打不过<code>Process.runSync(7za.exe,[&quot;a&quot;,...])</code></p><p>（不用Dart调用C而是直接用exe同时有水平不够和懒的原因 X）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>ROSA开发还是让我学到了不少东西，希望我踩的坑对你有帮助，感谢阅读，也感谢cdc对我的帮助。</p><p>项目地址：<a href="https://github.com/H2Sxxa/Rosa">https://github.com/H2Sxxa/Rosa</a> 欢迎Star，issue，PR与使用。</p>]]></content>
    
    
    <categories>
      
      <category>Development &amp; Progarmming</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dart</tag>
      
      <tag>Gradle</tag>
      
      <tag>Flutter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MAA通过无线调试连接手机运行</title>
    <link href="/2023/03/18/maa_wifi_connect/"/>
    <url>/2023/03/18/maa_wifi_connect/</url>
    
    <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>MAA是什么，可以自己去 [<a href="https://github.com/MaaAssistantArknights/MaaAssistantArknights">此处</a>] 了解，官网为 <code>maa.plus</code> ，其他连接方式（如模拟器）可以去 [<a href="https://maa.plus/docs/1.3-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%94%AF%E6%8C%81.html">此处</a>] 了解，此处不做赘言。</p><h2 id="2-准备工作"><a href="#2-准备工作" class="headerlink" title="2.准备工作"></a>2.准备工作</h2><h3 id="2-0-我需要什么？"><a href="#2-0-我需要什么？" class="headerlink" title="2-0.我需要什么？"></a>2-0.我需要什么？</h3><p>在此步骤中，您需要的一步附有无线调试的手机<em>（笔者使用的手机系统是ColorOSv11）</em>，一台能够运行基于<code>.NET 4.8</code>应用的电脑。</p><h3 id="2-1-ADB与连接手机"><a href="#2-1-ADB与连接手机" class="headerlink" title="2-1.ADB与连接手机"></a>2-1.ADB与连接手机</h3><h4 id="获取ADB"><a href="#获取ADB" class="headerlink" title="获取ADB"></a>获取ADB</h4><p>ADB是谷歌推出的一款专门用于连接手机进行调试的开发者工具，在此处充当MAA与手机通信的桥。</p><p><strong>可以点击 [<a href="https://dl.google.com/android/repository/platform-tools-latest-windows.zip">此处</a>] 下载</strong></p><p>下载后解压备用</p><h4 id="打开无线调试"><a href="#打开无线调试" class="headerlink" title="打开无线调试"></a>打开无线调试</h4><p>在打开这个之前，你得先打开手机的开发者模式，一般为多次点击系统版本号，这因手机而异。</p><p>找到系统的开发者选项，找到调试一栏，打开无线调试。</p><p>如果找的到<code>禁止权限监控</code>，建议也打开，否则MAA可能无法操作。</p><h4 id="配对设备并连接"><a href="#配对设备并连接" class="headerlink" title="配对设备并连接"></a>配对设备并连接</h4><p><strong>如果要使用无线连接必须连接到同一网络下，或者你可以去使用USB调试来连接，教程自寻</strong></p><p>无线调试可点击进入，里面有<code>使用配对码配对设备</code>，点击此选项，会出现一个弹窗，记录下配对地址端口与配对码。</p><p>假设我的地址端口和配对码如下</p><table><thead><tr><th>地址端口</th><th>127.0.0.1:40333</th></tr></thead><tbody><tr><td>配对码</td><td>123456</td></tr></tbody></table><p>在ADB解压后的文件夹打开终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\adb.exe pair 127.0.0.1:40333 #记得改成你自己的地址端口<br><span class="hljs-meta">#</span><span class="bash">正常会出现 Enter pairing code: 直接输入你的配对码回车即可</span><br></code></pre></td></tr></table></figure><p>配对成功后即可开始连接，在<code>使用配对码配对设备</code>上方，<code>设备名称</code>下方有一个用于连接的地址端口（并非上文的地址端口）</p><p>假设我的地址端口为<code>127.0.0.1:42222</code></p><p>在终端输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\adb.exe connect 127.0.0.1:42222<br><span class="hljs-meta">#</span><span class="bash">正常会出现connected to 127.0.0.1:42222</span><br>.\adb.exe devices #确认是否连接成功<br><span class="hljs-meta">#</span><span class="bash">List of devices attached</span><br><span class="hljs-meta">#</span><span class="bash">127.0.0.1:42222    device</span><br><span class="hljs-meta">#</span><span class="bash">adb-xxxxx-xxxxx._adb-tls-connect._tcp.      device 不用理他，这是另一种连接方式</span><br></code></pre></td></tr></table></figure><p>如果你这一步没什么问题，恭喜你已经成功一半了！</p><h3 id="2-2-手机分辨率"><a href="#2-2-手机分辨率" class="headerlink" title="2-2.手机分辨率"></a>2-2.手机分辨率</h3><p>MAA只能够通过16:9的分辨率工作，否则会出现无法连接的情况，下面给出2种方法来修改手机分辨率。</p><p>建议的分辨率如下</p><table><thead><tr><th>分辨率</th><th>1920x1080</th></tr></thead><tbody><tr><td>DPI（非强制）</td><td>480</td></tr></tbody></table><p><a href="https://maa.plus/docs/1.3-%E6%A8%A1%E6%8B%9F%E5%99%A8%E6%94%AF%E6%8C%81.html#%E2%9A%99%EF%B8%8F-%E6%89%8B%E6%9C%BA%E3%80%81%E5%B9%B3%E6%9D%BF%E7%AD%89%E9%9D%9E-16-9-%E5%88%86%E8%BE%A8%E7%8E%87%E8%AE%BE%E5%A4%87">MAA官方文档</a></p><h4 id="SecondScreen（推荐）"><a href="#SecondScreen（推荐）" class="headerlink" title="SecondScreen（推荐）"></a>SecondScreen（推荐）</h4><p>APK文件可以在 <a href="https://github.com/farmerbb/SecondScreen/releases/latest">[此处]</a> 获取，用法自行探索，不会可以上B站搜<code>SecondScreen</code>。</p><h4 id="手动修改"><a href="#手动修改" class="headerlink" title="手动修改"></a>手动修改</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\adb.exe -s 127.0.0.1:42222 shell #进入设备终端<br>wm size                               #查看当前设备的分辨率<br>wm size 1920x1080                      #调整分辨率<br></code></pre></td></tr></table></figure><h3 id="2-3-下载MAA"><a href="#2-3-下载MAA" class="headerlink" title="2-3.下载MAA"></a>2-3.下载MAA</h3><p>MAA可以在 <a href="https://github.com/MaaAssistantArknights/MaaAssistantArknights/releases/latest">[此处]</a> 获取</p><p>下载后解压备用，<strong>下载过慢查看其他问题</strong></p><h2 id="3-配置MAA"><a href="#3-配置MAA" class="headerlink" title="3.配置MAA"></a>3.配置MAA</h2><p>建议使用管理员权限打开<code>MAA.exe</code></p><h3 id="3-0-选择客户端类型"><a href="#3-0-选择客户端类型" class="headerlink" title="3-0.选择客户端类型"></a>3-0.选择客户端类型</h3><p>点击 设置-&gt;游戏设置 ，选择你的客户端（官服/B服/…）</p><h3 id="3-1-配置MAA的ADB连接"><a href="#3-1-配置MAA的ADB连接" class="headerlink" title="3-1.配置MAA的ADB连接"></a>3-1.配置MAA的ADB连接</h3><p>点击 设置-&gt;连接设置 ，关闭自动检测连接</p><ul><li>ADB绝对路径选择你的<code>adb.exe</code>的位置</li><li>连接地址即为上文<strong>你自己</strong> <code>.\adb.exe connect</code>的地址</li><li>连接配置因人而异，你可以用默认的通用模式</li><li>触控模式默认的<code>minitouch</code>如果手机没有<code>ROOT</code>，可能会出现连接成功没有反应，可以换用<code>MaaTouch</code>，<em>别TM用兼容模式</em>，还是不好使建议点击<code>强制替换ADB</code>，没事替换也没啥问题</li></ul><h3 id="3-2-Link-Start"><a href="#3-2-Link-Start" class="headerlink" title="3-2.Link Start!"></a>3-2.Link Start!</h3><p>如果上面的步骤你没啥问题，到这也就结束了，恭喜你完成了配置！</p><h2 id="4-其他问题"><a href="#4-其他问题" class="headerlink" title="4.其他问题"></a>4.其他问题</h2><h3 id="Github下载过慢"><a href="#Github下载过慢" class="headerlink" title="Github下载过慢"></a>Github下载过慢</h3><ol><li>请使用 浏览器 / IDM / FDM / Aria 等正规下载器下载文件，<strong>不要用某雷！</strong></li><li>请打开下载地址中您所需要版本的链接（非镜像站）</li><li>找到您所需要下载的文件链接</li><li>右键该链接，选择 <code>复制链接地址</code></li><li>将链接地址粘贴到浏览器地址栏</li><li>将链接地址中的 <code>github.com</code> 替换为 <code>download.fastgit.org</code></li><li>回车以开始下载</li></ol><p>也可以使用<code>ghproxy.com</code>（自己点进去看看）</p>]]></content>
    
    
    <categories>
      
      <category>Share &amp; Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Arknights</tag>
      
      <tag>MAA</tag>
      
      <tag>Android</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>记一次AIMP的DSP Stereo Tool插件安装</title>
    <link href="/2022/11/06/aimp_stereo_install/"/>
    <url>/2022/11/06/aimp_stereo_install/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前不久（大概），发现了AIMP居然可以使用插件，于是想着往这软件套个DSP，大概是因为假的音乐才好听（雾</p><p class="note warning">没有图，建议忍着点</p><h2 id="安装-dsp-stereo-tool"><a href="#安装-dsp-stereo-tool" class="headerlink" title="安装 dsp_stereo_tool"></a>安装 dsp_stereo_tool</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>先前往官网( <a href="https://www.stereotool.com/download">https://www.stereotool.com/download</a> )，左边上面有个Winamp/DSP plug-in version</p><p>下载后拿到了一个Installer了，然后就可以进入第二步了</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>双击后安装程序后，选择<code>Let me pick a Plugins directory</code>，点击<code>NEXT</code>，然后找到你的AIMP插件文件夹（例如<code>C:\Program Files (x86)\AIMP\Plugins</code>），新建一个<code>dsp_stereo_tool</code>文件夹，最后选中新建的那个文件夹点击Install，打开AIMP后你就能发现安装成功了</p><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p>你以为安装成功了吗，其实还不算完…如果现在结束的话虽然可以用，但是有时候会蹦出来烦人的滴滴声，对此可以用一些小手段”结束调研”完成注册，这里就不一一列举……</p>]]></content>
    
    
    <categories>
      
      <category>Share &amp; Misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Music</tag>
      
      <tag>AIMP</tag>
      
      <tag>DSP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MineCraft 1.12.2 开发教程 —— 1.构建环境并启动MC</title>
    <link href="/2022/10/16/mcforge1.12.2-1/"/>
    <url>/2022/10/16/mcforge1.12.2-1/</url>
    
    <content type="html"><![CDATA[<h2 id="构建环境"><a href="#构建环境" class="headerlink" title="构建环境"></a>构建环境</h2><h3 id="何为构建环境？"><a href="#何为构建环境？" class="headerlink" title="何为构建环境？"></a>何为构建环境？</h3><p>在了解构建环境之前，你需要知道一个名为 <strong>ForgeGradle</strong> 的东西，它的作用如下</p><blockquote><ul><li>部署开发环境（下载 Minecraft、反编译及反混淆 Minecraft、下载 assets），有三种：</li><li>基本上所有 Mod 开发者在平时开发 Mod 时都会使用的带反编译出的源码的开发环境（<code>setupDecompWorkspace</code> task)</li><li>持续集成服务器（CI）经常使用的用于自动构建 Mod 的环境（<code>setupCIWorkspace</code> task）</li><li>不太常用的仅有反混淆后的 Minecraft 的开发环境（<code>setupDevWorkspace</code> task）</li><li>依赖处理<ul><li>用于反混淆依赖项目的 scope（<code>deobfCompile</code> 和 <code>deobfProvided</code>），在开发跨 Mod 兼容或扩展 Mod 时经常用到</li></ul></li><li>IDE 相关<ul><li>自动生成 IntelliJ IDEA 的 Run/Debug Configuration（<code>genIntellijRuns</code> task）</li></ul></li><li>连带当前项目一起运行 Minecraft（不常用）：<ul><li>运行服务器（<code>runServer</code> task）</li><li>运行客户端（<code>runClient</code> task）</li></ul></li><li>在执行 Gradle Java 插件的 <code>build</code> task 时可自动完成对源码的重混淆</li></ul><p>作者：3TUSK 出处：<a href="https://harbinger.covertdragon.team/chapter-01/forgegradle.html">https://harbinger.covertdragon.team/chapter-01/forgegradle.html</a></p></blockquote><p>简单来说，构建环境就是把整个MC下到.gradle缓存里，同时进行几轮的反编译反混淆，便于 <code>runClient</code> 运行客户端调试与执行其他Gradle命令</p><h3 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h3><p>在开始之前，你需要清楚以下几点</p><ul><li>Forge的maven仓库位于国外，下载极易失败 (指某fastutil.jar 20MB+)</li><li>由于某些硬件软件问题，并不是所有人配置开发环境都能顺利 (1G/环境变量/……)</li><li>由于各种奇怪的操作，版本问题……只要有一个环节出了问题，基本就可以看见 <code>Build Failed</code> 了</li></ul><p>难道真的没有办法了吗？</p><p>答案是否，在长期的开发者开发过程中已经形成了几套优秀的方案，下文提供2个解决方案来解决构建环境的绝大多数网络问题，当然如果并非是网络问题，可以删除.gradle再次重试</p><blockquote><p>是的，因为各种乱七八糟的原因，部署环境的过程总是会有各种莫名其妙的问题。一般情况下， –debug、–stacktrace 直接莽拿到的信息足够 debug 用了。但有一点请注意：部署环境的过程中，因为涉及到几轮 mapping 和下载 Minecraft 的 assets，所以在没有预先部署好的环境留下的缓存的情况行，这个过程不会特别快。要有耐心。</p><p>然而，由于某些特殊原因，即使你有足够的耐心也不一定能部署成功。遇到这种情况时，你可以尝试通过为 Gradle 配置代理。相关资料很容易找到，这里不再赘述。</p><p>此外，还要明确一点：不是所有的错误都和网络有关系。请不要盲目尝试各种所谓的解决方案——虽然，直接删了 .gradle 缓存目录可以解决 90% 的非网络因素引发的问题。</p><p>作者：3TUSK 出处：<a href="https://harbinger.covertdragon.team/chapter-02/">https://harbinger.covertdragon.team/chapter-02/</a></p></blockquote><ul><li><p><a href="https://github.com/IAXRetailer/MCreator_Setup/wiki/%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E4%BB%A3%E7%90%86Forge(java)%E6%9D%A5%E5%8A%A0%E9%80%9F%E6%9E%84%E5%BB%BA%E7%8E%AF%E5%A2%83">Proxifier or TUN模式代理Gradle</a></p></li><li><p>使用代理镜像Maven源，类似于阿里云….，也有现成的框架，类似于<a href="https://github.com/IdeallandEarthDept/IdeallandFramework">IDF</a>，不过你可能需要把<a href="https://github.com/IdeallandEarthDept/IdeallandFramework/blob/master/build.gradle#L42">build.gradle这部分</a>改为下文那样，从而使用2847版本的MDK，不过2768其实也影响不大…看个人选择吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">minecraft &#123;<br>    version = <span class="hljs-string">&quot;1.12.2-14.23.5.2847&quot;</span> <span class="hljs-comment">//改为1.12.2-14.23.5.2847，此处已更改</span><br>    runDir = <span class="hljs-string">&quot;run&quot;</span><br><br>    <span class="hljs-comment">// the mappings can be changed at any time, and must be in the following format.</span><br>    <span class="hljs-comment">// snapshot_YYYYMMDD   snapshot are built nightly.</span><br>    <span class="hljs-comment">// stable_#            stables are built at the discretion of the MCP team.</span><br>    <span class="hljs-comment">// Use non-default mappings at your own risk. they may not always work.</span><br>    <span class="hljs-comment">// simply re-run your setup task after changing the mappings to update your workspace.</span><br>    mappings = <span class="hljs-string">&quot;snapshot_20171003&quot;</span><br>    <span class="hljs-comment">// makeObfSourceJar = false // an Srg named sources jar is made by default. uncomment this to disable.</span><br>&#125;<br><br></code></pre></td></tr></table></figure></li></ul><h3 id="一些修改建议"><a href="#一些修改建议" class="headerlink" title="一些修改建议"></a>一些修改建议</h3><h4 id="修改Gradle版本至4-9"><a href="#修改Gradle版本至4-9" class="headerlink" title="修改Gradle版本至4.9"></a>修改Gradle版本至4.9</h4><ol><li>打开MDK目录下gradle\wrapper文件夹</li><li>打开gradle-wrapper.properties文件</li><li>将内容改为下文所述，其中distributionUrl的是否使用腾讯云镜像是可选的，如果不需要使用镜像，可以把distributionUrl的值改为<code>https\://services.gradle.org/distributions/gradle-4.9-all.zip</code></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">distributionBase</span>=<span class="hljs-string">GRADLE_USER_HOME</span><br><span class="hljs-attr">distributionPath</span>=<span class="hljs-string">wrapper/dists</span><br><span class="hljs-comment"># Tecent cloud mirror</span><br><span class="hljs-attr">distributionUrl</span>=<span class="hljs-string">https\://mirrors.cloud.tencent.com/gradle/gradle-4.9-all.zip</span><br><span class="hljs-comment"># Source address</span><br><span class="hljs-comment">#distributionUrl=https\://services.gradle.org/distributions/gradle-4.9-all.zip</span><br><span class="hljs-attr">zipStoreBase</span>=<span class="hljs-string">GRADLE_USER_HOME</span><br><span class="hljs-attr">zipStorePath</span>=<span class="hljs-string">wrapper/dists</span><br></code></pre></td></tr></table></figure><h3 id="开始构建！"><a href="#开始构建！" class="headerlink" title="开始构建！"></a>开始构建！</h3><p>打开MDK目录下的README.txt，你会看到以下内容</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">Step <span class="hljs-number">1</span>: <span class="hljs-keyword">Open</span> your command-<span class="hljs-literal">line</span> <span class="hljs-keyword">and</span> browse <span class="hljs-keyword">to</span> the folder where you extracted the zip <span class="hljs-keyword">file</span>.<br><br>Step <span class="hljs-number">2</span>: Once you have a command window up <span class="hljs-keyword">in</span> the folder that the downloaded material was placed, <span class="hljs-keyword">type</span>:<br><br>Windows: <span class="hljs-string">&quot;gradlew setupDecompWorkspace&quot;</span><br>Linux/Mac OS: <span class="hljs-string">&quot;./gradlew setupDecompWorkspace&quot;</span><br><br>Step <span class="hljs-number">3</span>: <span class="hljs-keyword">After</span> <span class="hljs-keyword">all</span> that finished, you<span class="hljs-symbol">&#x27;re</span> left <span class="hljs-keyword">with</span> a choice.<br><span class="hljs-keyword">For</span> eclipse, run <span class="hljs-string">&quot;gradlew eclipse&quot;</span> (./gradlew eclipse <span class="hljs-keyword">if</span> you are <span class="hljs-keyword">on</span> Mac/Linux)<br><br><span class="hljs-keyword">If</span> you prefer <span class="hljs-keyword">to</span> <span class="hljs-keyword">use</span> IntelliJ, steps are a little different.<br><span class="hljs-number">1</span>. <span class="hljs-keyword">Open</span> IDEA, <span class="hljs-keyword">and</span> import project.<br><span class="hljs-number">2</span>. <span class="hljs-keyword">Select</span> your build.gradle <span class="hljs-keyword">file</span> <span class="hljs-keyword">and</span> have it import.<br><span class="hljs-number">3</span>. Once it<span class="hljs-symbol">&#x27;s</span> finished you must close IntelliJ <span class="hljs-keyword">and</span> run the following command:<br><br><span class="hljs-string">&quot;gradlew genIntellijRuns&quot;</span> (./gradlew genIntellijRuns <span class="hljs-keyword">if</span> you are <span class="hljs-keyword">on</span> Mac/Linux)<br><br>Step <span class="hljs-number">4</span>: The final step <span class="hljs-keyword">is</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">open</span> Eclipse <span class="hljs-keyword">and</span> switch your workspace <span class="hljs-keyword">to</span> /eclipse/ (<span class="hljs-keyword">if</span> you <span class="hljs-keyword">use</span> IDEA, it should automatically start <span class="hljs-keyword">on</span> your project)<br><br></code></pre></td></tr></table></figure><p>大致的意思由以下几个步骤组成</p><ol><li><p>在你的mdk目录下打开CMD或者PowerShell窗口</p></li><li><p>输入<code>gradlew setupDecompWorkspace</code></p></li><li><p>如果你使用eclipse等上述任务结束后输入<code>gradlew eclipse</code></p></li><li><p>如果你使用IntelliJ IDEA，等上述任务结束，<strong>先选择build.gradle把项目导入IDEA后关闭IDEA</strong>，在确保IDEA关闭后输入<code>gradlew genIntellijRuns</code> </p><ul><li>如何导入build.gradle? File-&gt;Open-&gt;选择你的build.gradle后点击ok，把作为项目打开</li></ul></li><li><p>VSCode在ForgeGradle2.3没有相应的Gradle Task，如果你使用LCF，此处你直接导入即可（记得装Gradle插件）</p></li></ol><h3 id="构建失败？"><a href="#构建失败？" class="headerlink" title="构建失败？"></a>构建失败？</h3><p>如果你构建成功了请跳过此步</p><p>先前往<a href="https://mouse0w0.github.io/setup-mdk-guide">这里</a>查询有无与你相似的错误，使用对应的方案解决，如果没有可以选择向他人求助</p><h2 id="在IDE中启动MC"><a href="#在IDE中启动MC" class="headerlink" title="在IDE中启动MC"></a>在IDE中启动MC</h2><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>IDEA入成功后，拉出右边的Gradle标签，会有对应的任务，运行<code>runClient</code>即可启动客户端</p><h3 id="VSCode-不支持FG2-3"><a href="#VSCode-不支持FG2-3" class="headerlink" title="VSCode(不支持FG2.3)"></a>VSCode(不支持FG2.3)</h3><p>安装Gradle插件后，在Gradle选项卡处可以找到你的<code>runClient</code></p><h3 id="手动启动"><a href="#手动启动" class="headerlink" title="手动启动"></a>手动启动</h3><p>在项目目录打开终端运行<code>.\gradlew runClient</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Harbinger <a href="https://harbinger.covertdragon.team/">https://harbinger.covertdragon.team</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Minecraft Forge 1.12.2 Development Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Forge</tag>
      
      <tag>Minecraft</tag>
      
      <tag>1.12.2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MineCraft 1.12.2 开发教程 —— 0.准备工作</title>
    <link href="/2022/10/16/mcforge1.12.2-0/"/>
    <url>/2022/10/16/mcforge1.12.2-0/</url>
    
    <content type="html"><![CDATA[<h2 id="须知"><a href="#须知" class="headerlink" title="须知"></a>须知</h2><ul><li>这是Minecraft Forge Mod教程而不是Minecraft Bedrock Mod或者Minecraft Farbic Mod</li><li>本文不讨论MCreator，只讨论古典法：使用Java语言，在Forge的基础上做mod</li><li>使用的Forge MDK版本为<strong>Forge 14.23.5.2847</strong>，其他版本请勿反复提问</li><li>MacOS用户观看此教程请自力更生</li></ul><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在您开始阅读此教程前，请先回答以下几个问题</p><h3 id="你懂Java吗-or-你知道面向对象的含义吗-？"><a href="#你懂Java吗-or-你知道面向对象的含义吗-？" class="headerlink" title="你懂Java吗 or 你知道面向对象的含义吗 ？"></a>你懂Java吗 or 你知道面向对象的含义吗 ？</h3><ul><li><p>简述instanceof</p></li><li><p>简述面向对象</p></li><li><p>简述装饰器</p></li><li><p>简述类/包</p></li><li><p>……</p><p>如果你不懂，当然没有关系，因为笔者刚接触时也不懂Java，也是通过一路的摸爬滚打才弄明白的，你现在Go to learn Java还不算迟</p><blockquote><p>有些人会编程但不会Java，这很正常，毕竟世界上有那么多编程语言，正常人都不会样样精通。</p><p>如果你懂面向对象，那么找一个介绍java语法的教程即可。这里我推荐菜鸟教程——<a href="https://www.runoob.com/java/java-tutorial.html">https://www.runoob.com/java/java-tutorial.html</a></p><p>适合会编程的人，没什么废话。不适合完全不会编程的新手。</p><p>作者：道家深湖 <a href="https://www.bilibili.com/read/cv12067660">https://www.bilibili.com/read/cv12067660</a> 出处：bilibili</p></blockquote></li></ul><h3 id="你有IDE吗？"><a href="#你有IDE吗？" class="headerlink" title="你有IDE吗？"></a>你有IDE吗？</h3><p>如果没有，这里有3个选择：</p><ul><li><a href="https://www.jetbrains.com/idea/download">IntelliJ IDEA Community</a> (当然，如果你有钱可以选择UItimate，不过这并不影响开发)</li><li><a href="https://www.eclipse.org/downloads">Eclipse</a></li><li><a href="https://code.visualstudio.com/Download">Visual Studio Code</a></li></ul><p>这里推荐使用IDEA Community版本，推荐的版本为最新版，因为绝大多数的开发者使用的为此软件，便于提问</p><p>不过在本教程中，笔者将使用VSCode来示范代码，不必担心，对于IDEA部分必要功能我也会提，但是对于Eclipse我就爱莫能助了</p><h3 id="你有Java吗？"><a href="#你有Java吗？" class="headerlink" title="你有Java吗？"></a>你有Java吗？</h3><p>如果你想要开发1.12.2的Mod，你需要一个Java8 (JDK)</p><ul><li><a href="https://adoptopenjdk.net/">AdoptOpenJDK</a></li><li><a href="https://www.oracle.com/java/technologies/downloads/">Oracle JDK</a></li><li>……</li></ul><p>下载太慢？试看看<a href="https://mirrors.tuna.tsinghua.edu.cn/Adoptium/8/jdk/x64/windows/">清华源</a>，注意下载.msi而不是zip，除非你完全能区分明白这2东西</p><p>等等，还没完，当你安装完成之后，请务必检查一下JAVA_HOME，不过你也可以在IDE里设置项目SDK，然后在IDE里构建开发…</p><p>对于我来说，JAVA_HOME在没有多版本开发需求下是较优选；不会配置JAVA_HOME？<a href="https://www.runoob.com/java/java-environment-setup.html">点击此处</a></p><h3 id="你有MDK吗-？or-MDK是什么？"><a href="#你有MDK吗-？or-MDK是什么？" class="headerlink" title="你有MDK吗 ？or MDK是什么？"></a>你有MDK吗 ？or MDK是什么？</h3><p>MDK（Mod Development Kit）是Forge提供的一个工具，集成了ForgeGradle以及其他东西</p><p>所有1.12.2的MDK可以在<a href="https://files.minecraftforge.net/net/minecraftforge/forge/index_1.12.2.html">这里</a>找到</p><ul><li>MDK2847下载地址 <a href="https://maven.minecraftforge.net/net/minecraftforge/forge/1.12.2-14.23.5.2847/forge-1.12.2-14.23.5.2847-mdk.zip">https://maven.minecraftforge.net/net/minecraftforge/forge/1.12.2-14.23.5.2847/forge-1.12.2-14.23.5.2847-mdk.zip</a></li></ul><h4 id="考虑使用自建框架进行开发"><a href="#考虑使用自建框架进行开发" class="headerlink" title="考虑使用自建框架进行开发"></a>考虑使用自建框架进行开发</h4><h5 id="IDF-Idealland-Framework-适合完全-0-基础的小白"><a href="#IDF-Idealland-Framework-适合完全-0-基础的小白" class="headerlink" title="IDF(Idealland Framework) - 适合完全 0 基础的小白"></a>IDF(Idealland Framework) - 适合完全 0 基础的小白</h5><p><a href="https://github.com/IdeallandEarthDept/IdeallandFramework">https://github.com/IdeallandEarthDept/IdeallandFramework</a></p><blockquote><p>IDF，Idealland Framework（理想境框架），是指基于理想境mod源码删减之后得出的一台框架。</p><p>IDL，Idealland，理想境的简称。</p><p>MDK，Mod Development Kit，模组开发包的简称。 </p><p>作者：道家深湖 <a href="https://www.bilibili.com/read/cv19031222">https://www.bilibili.com/read/cv19031222</a> 出处：bilibili</p></blockquote><p>值得一提的是，IDF几乎为您配好了所有镜像环境，因此在下一步构建环境也会轻松许多</p><p>如果不需要IDF提供的代码，那我推荐你使用LCF</p><h5 id="LCF-LunarCapitalFrameWork-适合有其他语言基础的小白"><a href="#LCF-LunarCapitalFrameWork-适合有其他语言基础的小白" class="headerlink" title="LCF(LunarCapitalFrameWork) - 适合有其他语言基础的小白"></a>LCF(LunarCapitalFrameWork) - 适合有其他语言基础的小白</h5><p><a href="https://github.com/TeamGensouSpark/LunarCapitalFramework">https://github.com/TeamGensouSpark/LunarCapitalFramework</a></p><p>LunarCapitalFrameWork（月都框架），是由我基于IDF与Cleanroommc的TDE框架整合而成的另一类框架。</p><p>与TDE一样配备了 <strong>Gradle 8.1.1</strong> + <strong><a href="https://github.com/GTNewHorizons/RetroFuturaGradle">RetroFuturaGradle</a></strong> + <strong>Forge 14.23.5.2847</strong>，但并不是全镜像</p><p>额外还将打算支持添加项目生成器与管理器脚本（依赖于Python）</p><h3 id="需要更多帮助-or-看看其他的教程"><a href="#需要更多帮助-or-看看其他的教程" class="headerlink" title="需要更多帮助 or 看看其他的教程"></a>需要更多帮助 or 看看其他的教程</h3><blockquote><p>1【视频，1.12.2】深湖出品的《边睡觉边开发Mod》</p><ul><li><a href="https://www.bilibili.com/video/BV1Ar4y1K7Qk">https://www.bilibili.com/video/BV1Ar4y1K7Qk</a></li></ul><p>2【网页，1.12.2】由3TUSK牵头的教程《Harbinger》</p><ul><li><a href="https://harbinger.covertdragon.team/">https://harbinger.covertdragon.team/</a></li></ul><p>3【书籍，1.12.2】由土球（zzzz_ustc）撰写的书籍《我的世界：Minecraft模组开发指南》</p><ul><li>各大网购平台有售，搜索书名即可。</li></ul><p>4【网页，1.16】由FledgeXu撰写的《Boson》。不过由于作者本人已经不打算维护，所以本教程需要在熟练Modder监护下阅读，不然你可能上来就卡住。</p><ul><li><a href="https://boson.v2mcdev.com/introducation/intro.html">https://boson.v2mcdev.com/introducation/intro.html</a></li></ul><p>5【汇总】MCBBS的教程帖汇总。很多，不算全，我推荐的就是上面那几个了。除了汇总贴，bbs也有很多其他资源可供各位自行发掘。</p><ul><li><a href="https://www.mcbbs.net/thread-54579-1-1.html">https://www.mcbbs.net/thread-54579-1-1.html</a></li></ul><p>6【离线包】离线包汇总。对于那些因为在大陆网络受限，而构建工作环境失败的人会有帮助。</p><ul><li><a href="https://www.mcbbs.net/thread-896542-1-1.html">https://www.mcbbs.net/thread-896542-1-1.html</a></li></ul><p>7【MCWiki】作为modder，有的时候你需要查mc原版的一些信息，来这就对了。</p><ul><li><a href="https://minecraft.fandom.com/zh/wiki/">https://minecraft.fandom.com/zh/wiki/</a></li></ul><p>8【mod集散地】Curseforge，国际Mod汇总处，你想知道这世界上都有什么mod吗？</p><ul><li><a href="https://www.curseforge.com/minecraft/mc-mods">https://www.curseforge.com/minecraft/mc-mods</a></li></ul><p>9【中文Mod百科】MCMod，中文的mod wiki。虽然不是世界上所有mod都有，但也相当不错了。</p><ul><li><a href="https://www.mcmod.cn/">https://www.mcmod.cn/</a></li></ul><p>10【Github】Github就是github。</p><ul><li>链接略，国内不稳定 </li></ul><p>作者：道家深湖 <a href="https://www.bilibili.com/read/cv12067660">https://www.bilibili.com/read/cv12067660</a> 出处：bilibili</p></blockquote><h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><ul><li>MDK 配置指南 <a href="https://mouse0w0.github.io/setup-mdk-guide">https://mouse0w0.github.io/setup-mdk-guide</a></li><li>MDK 开发指南 <a href="https://github.com/mouse0w0/MinecraftDeveloperGuide">https://github.com/mouse0w0/MinecraftDeveloperGuide</a></li><li>一个由我提供的MOD开发群组 <a href="https://jq.qq.com/?_wv=1027&amp;k=c14qiAAd">https://jq.qq.com/?_wv=1027&amp;k=c14qiAAd</a></li></ul><h2 id="再次检查然后开始吧"><a href="#再次检查然后开始吧" class="headerlink" title="再次检查然后开始吧"></a>再次检查然后开始吧</h2><h3 id="确认Java版本（此步仅MDK）"><a href="#确认Java版本（此步仅MDK）" class="headerlink" title="确认Java版本（此步仅MDK）"></a>确认Java版本（此步仅MDK）</h3><p>打开PowerShell or CMD输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br></code></pre></td></tr></table></figure><p>如果一切正常，看起来会是这样的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">C:\Users\Administrator&gt;java -version<br>java version &quot;1.8.0_...&quot;<br>Java(TM) SE Runtime Environment (build 1.8.0_...)<br>Java HotSpot(TM) 64-Bit Server VM (build ..., mixed mode)<br></code></pre></td></tr></table></figure><p>请确认java version是<strong>1.8.0</strong>而不是其他(“ _ “后面可以忽略)，或者你可以在你的IDE里面更改项目SDK</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Harbinger <a href="https://harbinger.covertdragon.team/">https://harbinger.covertdragon.team</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>道家深湖指路明灯等文章 (出处文中均有提到)<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Minecraft Forge 1.12.2 Development Tutorial</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Forge</tag>
      
      <tag>Minecraft</tag>
      
      <tag>1.12.2</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
